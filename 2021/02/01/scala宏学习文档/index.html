<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>scala宏学习文档</title><meta name="description" content="胸无大致，家里蹲！"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon" href="/chuanblog.github.io/images/favicon.ico"><link rel="stylesheet" href="/chuanblog.github.io/style/bulma.css"><link rel="stylesheet" href="/chuanblog.github.io/style/base.css"><link rel="stylesheet" href="/chuanblog.github.io/style/helper.css"><script src="/chuanblog.github.io/js/common.js"></script><link rel="stylesheet" href="/chuanblog.github.io/style/post.css"><link rel="stylesheet" href="/chuanblog.github.io/style/highlight-theme-light.css"><script src="/chuanblog.github.io/jslib/highlight.pack.js"></script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/chuanblog.github.io/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/chuanblog.github.io/">chuan's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">scala宏学习文档</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/chuanblog.github.io/">Home</a></h3><h3 class="is-inline-block"><a href="/chuanblog.github.io/about">About</a></h3><h3 class="is-inline-block"><a href="/chuanblog.github.io/archives">Archives</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/chuanblog.github.io/">Home</a></h3><h3 class="is-inline-block"><a href="/chuanblog.github.io/about">About</a></h3><h3 class="is-inline-block"><a href="/chuanblog.github.io/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE"><span class="toc-text">创建测试项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="toc-text">定义一个宏函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91-AST-%E5%92%8Cq%E6%8F%92%E5%80%BC%E5%99%A8"><span class="toc-text">抽象语法树(AST)和q插值器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%B7%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E6%96%B9%E6%B3%95"><span class="toc-text">定义具有类型参数的宏方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8macro-bundle%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-text">使用macro bundle的方式定义宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E5%AE%8F"><span class="toc-text">定义隐式宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%99%A8%E5%AE%8F"><span class="toc-text">提取器宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/chuanblog.github.io/tags/scala"><i class="tag post-item-tag">scala</i></a><a href="/chuanblog.github.io/tags/%E5%AE%8F"><i class="tag post-item-tag">宏</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">scala宏学习文档</h1><time class="has-text-grey" datetime="2021-02-01T13:55:29.000Z">2021-02-01</time><article class="mt-2 post-content"><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE">创建测试项目</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AE%8F%E5%87%BD%E6%95%B0">定义一个宏函数</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91ast%E5%92%8Cq%E6%8F%92%E5%80%BC%E5%99%A8">抽象语法树(AST)和q插值器</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%85%B7%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E6%96%B9%E6%B3%95">定义具有类型参数的宏方法</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8macro-bundle%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%AE%8F">使用macro bundle的方式定义宏</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E5%AE%8F">定义隐式宏</a></li>
<li><a href="#%E6%8F%90%E5%8F%96%E5%99%A8%E5%AE%8F">提取器宏</a></li>
<li><a href="#"></a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文适用于scala 2.13.x版本。</p>
<h2 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h2><p>由于宏和测试用代码不能存在于同一个编译环境下，故使用sbt创建一个主项目，然后在主项目中创建子项目，用来存放宏代码,下面开始干。</p>
<p>首先，创建项目目录,进入项目目录：</p>
<pre><code class="hljs plain">$ mkdir macro-doc-sample
$ cd macro-doc-sample</code></pre>
<p>新建build.sbt文件：</p>
<pre><code class="hljs plain">$ touch build.sbt</code></pre>
<p>打开build.sbt输入如下配置：</p>
<pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> scalav = <span class="hljs-string">"2.13.3"</span>

<span class="hljs-comment">// 所有项目的公用配置</span>
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> commonSettings = <span class="hljs-type">Seq</span>(
  scalaVersion := scalav,
  organization := <span class="hljs-string">"me.zjc"</span>
)

<span class="hljs-comment">//scala宏在scala反射库中，需要手动引入</span>
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> scalaReflect = <span class="hljs-string">"org.scala-lang"</span> % <span class="hljs-string">"scala-reflect"</span> % scalav

<span class="hljs-comment">// 根目录项目</span>
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">"."</span>))
  .dependsOn(macros)
  .settings(
    name := <span class="hljs-string">"macro-doc-sample"</span>,
    commonSettings
  )

<span class="hljs-comment">// 宏项目</span>
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> macros = (project in file(<span class="hljs-string">"macros"</span>))
  .settings(
    name := <span class="hljs-string">"macros"</span>,
    commonSettings,
    libraryDependencies += scalaReflect
  )</code></pre>
<p>使用sbt加载项目：</p>
<pre><code class="hljs plain">$ sbt</code></pre>
<p>加载完毕，在两个项目中分别创建源码文件夹：</p>
<pre><code class="hljs plain">$ mkdir -p src/main/scala/me/zjc/macrodocsample
$ mkdir -p macros/src/main/scala/me/zjc/macros</code></pre>
<p>OK，可以开始写宏了！</p>
<h2 id="定义一个宏函数"><a href="#定义一个宏函数" class="headerlink" title="定义一个宏函数"></a>定义一个宏函数</h2><p>在macro项目源码目录新建文件HelloMacro.scala，输入如下代码:</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span>
<span class="hljs-keyword">import</span> scala.language.experimental.macros

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloMacro</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span></span>(msg: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = macro helloImpl

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {
    <span class="hljs-keyword">import</span> c.universe._
    <span class="hljs-keyword">val</span> result = <span class="hljs-string">q""</span><span class="hljs-string">"println("</span>hello <span class="hljs-string">" + $msg)"</span><span class="hljs-string">""</span>
    c.<span class="hljs-type">Expr</span>(result)
  }
}</code></pre>
<p>首先来看开头导入的<code>scala.reflect.macros.whitebox.Context</code>和<code>scala.language.experimental.macros</code>，导入前者是为了可以使用宏环境(Context),宏环境可以理解为宏在运行时所以依赖的环境，编写宏需要从这个环境中获取各种各样的信息，宏还可以通过这个环境中反馈一些信息给用户，环境分为白盒环境(whitebox.Context)和黑盒环境(blackbox.Context),具体区别以后在说，目前不做讨论。导入后者是为了能正常使用<code>macro</code>关键字。</p>
<p>接下来看两个方法<code>Hello</code>和<code>HelloImpl</code>,我们写好宏之后，我们只调用<code>hello</code>方法，并不会去直接使用<code>HelloImpl</code>方法,使用<code>hello</code>方法就像调用普通的方法一样：</p>
<pre><code class="hljs scala"><span class="hljs-type">HelloMacro</span>.hello(<span class="hljs-string">"macro"</span>)</code></pre>
<p>在编译器编译之后，会对上面的方法进行宏展开，所以在我们眼里代码是长上面这个样子的，但是在JVM眼中，代码长下面这个样子：</p>
<pre><code class="hljs scala">println(<span class="hljs-string">"hello "</span> + <span class="hljs-string">"macro"</span>)</code></pre>
<p>OK，现在我们来观察<code>helloImpl</code>,顾名思义，这是<code>hello</code>宏方法的具体实现，定义<code>helloImpl</code>方法是讲究格式的，第一个参数必须是<code>Context</code>宏环境，第二个参数必须和<code>hello</code>方法的第一个参数同名，如果<code>hello</code>有多个参数依次类推，这些参数的类型需要为<code>c.Expr[hello方法参数对应类型]</code>，返回类型<code>c.Expr[hello方法返回值类型]</code>,当然，如果你想图方便可以将参数类型和返回类型统一设置为<code>c.Tree</code>。</p>
<h2 id="抽象语法树-AST-和q插值器"><a href="#抽象语法树-AST-和q插值器" class="headerlink" title="抽象语法树(AST)和q插值器"></a>抽象语法树(AST)和q插值器</h2><p>开始写宏的具体实现之前我们需要对scala的抽象语法树和q插值器进行介绍,抽象语法树即代码树，是代码的树型表示法，打个比方，一个简单的代码片段：</p>
<pre><code class="hljs plain">AObjct.bFunc()</code></pre>
<p>转换为抽象语法树之后将会变为如下：</p>
<pre><code class="hljs plain">Apply(Select(Ident(TermName("AObjct")), TermName("bFunc")), List())</code></pre>
<p>本质是，scala2版本的宏就是对着上面这玩意儿编程，我们在把目光放到<code>helloImpl</code>方法上,它接收一个参数<code>msg: c.Expr[String]</code>,其实他本质上接收的就是一个抽象语法树，比如当我们给<code>hello</code>方法传入<code>"macro"</code>时，<code>helloImpl</code>方法接受到的参数长这样:</p>
<pre><code class="hljs plain">Literal(Constant("macro"))</code></pre>
<p>聪明的你可能已经注意到，<code>helloImpl</code>方法的返回值依然是一个<code>c.Expr[Unit]</code>,所以当我们想要让<code>hello</code>方法宏展开之后变为<code>println("hello macro")</code>的话，我们就需要将<code>println("hello macro")</code>变成一颗抽象语法树返回回来，它的语法树长这样:</p>
<pre><code class="hljs scala"><span class="hljs-type">Apply</span>(<span class="hljs-type">Ident</span>(<span class="hljs-type">TermName</span>(<span class="hljs-string">"println"</span>)), <span class="hljs-type">List</span>(<span class="hljs-type">Literal</span>(<span class="hljs-type">Constant</span>(<span class="hljs-string">"hello macro"</span>))))</code></pre>
<p>所以<code>helloImpl</code>方法应该长这样:</p>
<pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {
  <span class="hljs-keyword">import</span> c.universe._
  <span class="hljs-keyword">val</span> tree =
    <span class="hljs-type">Apply</span>(<span class="hljs-type">Ident</span>(<span class="hljs-type">TermName</span>(<span class="hljs-string">"println"</span>)), <span class="hljs-type">List</span>(<span class="hljs-type">Literal</span>(<span class="hljs-type">Constant</span>(<span class="hljs-string">"hello macro"</span>))))
  c.<span class="hljs-type">Expr</span>(tree)
}</code></pre>
<p>好的，我们新建一个Main(src/main/scala/me/zjc/macrodocsample/Main.scala)对象测试一下：</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macrodocsample

<span class="hljs-keyword">import</span> me.zjc.macros.<span class="hljs-type">HelloMacro</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{
  <span class="hljs-type">HelloMacro</span>.hello(<span class="hljs-string">""</span>)
}</code></pre>
<p>使用sbt运行项目:</p>
<pre><code class="hljs plain">$ sbt
$ run</code></pre>
<p>不出意外可以成功打印”hello macro”,上面的例子并没有运用上传入参数msg，就已经让人头疼了，更何况以后更复杂的情况。所以q插值器出现了，上面的例子如果使用q插值器，将会变成你所熟悉的样子：</p>
<pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {
  <span class="hljs-keyword">import</span> c.universe._
  <span class="hljs-keyword">val</span> tree = <span class="hljs-string">q""</span><span class="hljs-string">"println("</span>hello <span class="hljs-string">macro")"</span><span class="hljs-string">""</span>
  c.<span class="hljs-type">Expr</span>(tree)
}</code></pre>
<p>再次运行项目，得到同样的结果，此时我们还可以将msg参数代入到抽象语法树中:</p>
<pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {
  <span class="hljs-keyword">import</span> c.universe._
  <span class="hljs-keyword">val</span> tree = <span class="hljs-string">q""</span><span class="hljs-string">"println("</span>hello <span class="hljs-string">" + $msg)"</span><span class="hljs-string">""</span>
  c.<span class="hljs-type">Expr</span>(tree)
}</code></pre>
<p>q插值器可以将我们输入的字符串转换成抽象语法树，就是这么神奇。具体的q插值器的使用还可以参考翔一样的<a target="_blank" rel="noopener" href="https://docs.scala-lang.org/overviews/quasiquotes/intro.html">官方文档。</a></p>
<h2 id="定义具有类型参数的宏方法"><a href="#定义具有类型参数的宏方法" class="headerlink" title="定义具有类型参数的宏方法"></a>定义具有类型参数的宏方法</h2><p>我们在macro子项目中新建文件<code>MacroWithType.scala</code>:</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> scala.language.experimental.macros
<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroWithType</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNonParamObj</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">T</span> = macro getNonParamObjImpl[<span class="hljs-type">T</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNonParamObjImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](c: <span class="hljs-type">Context</span>): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>] = {
    <span class="hljs-keyword">import</span> c.universe._
    <span class="hljs-keyword">val</span> t = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]
    <span class="hljs-keyword">val</span> result = <span class="hljs-string">q"new <span class="hljs-subst">$t</span>()"</span>
    c.<span class="hljs-type">Expr</span>(result)
  }
}</code></pre>
<p>定义impl方法时候加入bundle context参数<code>c.WeakTypeTag</code>即可，使用上面的例子可以用来实例化所有构造器可以不需要传入参数的类，我们可以来测试一下，下面我们用scalaTest来测试我们的代码,加入scalaTest依赖:</p>
<pre><code class="hljs scala"><span class="hljs-comment">// 宏项目</span>
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> macros = (project in file(<span class="hljs-string">"macros"</span>))
  .settings(
    name := <span class="hljs-string">"macros"</span>,
    commonSettings,
    libraryDependencies ++= <span class="hljs-type">Seq</span>(
      scalaReflect,
      <span class="hljs-string">"org.scalatest"</span> %% <span class="hljs-string">"scalatest"</span> % <span class="hljs-string">"3.2.2"</span> % <span class="hljs-string">"test"</span>
    )
  )</code></pre>
<p>创建测试目录<code>macros/src/test/scala/me/zjc/macros/</code>,新建文件<code>MacroWithTypeTest.scala</code>:</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> org.scalatest.funsuite.<span class="hljs-type">AnyFunSuite</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroWithTypeTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>
<span class="hljs-class">  <span class="hljs-title">test</span>(<span class="hljs-params">"generate a no param constructor class <span class="hljs-type">A</span>"</span>) </span>{
    <span class="hljs-keyword">val</span> a = <span class="hljs-type">MacroWithType</span>.getNonParamObj[<span class="hljs-type">A</span>]
    assert(a.isInstanceOf[<span class="hljs-type">A</span>])
  }
}</code></pre>
<p>运行测试:</p>
<pre><code class="hljs plain">$ sbt
$ project macros
$ test</code></pre>
<p>不出意外将会看见all tests passed。</p>
<h2 id="使用macro-bundle的方式定义宏"><a href="#使用macro-bundle的方式定义宏" class="headerlink" title="使用macro bundle的方式定义宏"></a>使用macro bundle的方式定义宏</h2><p>因为比较好理解，直接show code，创建<code>MacroWithBundle.scala</code>:</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> scala.language.experimental.macros
<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroWithBundle</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroWithBundleFunc</span></span>: <span class="hljs-type">String</span> = macro <span class="hljs-type">Macros</span>.impl

  <span class="hljs-comment">// 这就是macro bundle</span>
  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Macros</span>(<span class="hljs-params">val /*这个val不能漏掉*/ c: <span class="hljs-type">Context</span></span>) </span>{
    <span class="hljs-keyword">import</span> c.universe._
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">impl</span></span>: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>] = {
      <span class="hljs-keyword">val</span> resultStr = <span class="hljs-string">"hello macro"</span>
      c.<span class="hljs-type">Expr</span>(<span class="hljs-string">q""</span><span class="hljs-string">"$resultStr"</span><span class="hljs-string">""</span>)
    }
  }
}</code></pre>
<p>测试代码:</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> org.scalatest.funsuite.<span class="hljs-type">AnyFunSuite</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroWithBundleTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>{
  test(<span class="hljs-string">""</span><span class="hljs-string">"invok macro method will get a String value "</span>hello <span class="hljs-string">macro" "</span><span class="hljs-string">""</span>) {
    assert(<span class="hljs-type">MacroWithBundle</span>.macroWithBundleFunc == <span class="hljs-string">"hello macro"</span>)
  }
}</code></pre>
<h2 id="定义隐式宏"><a href="#定义隐式宏" class="headerlink" title="定义隐式宏"></a>定义隐式宏</h2><p>新建一个文件<code>ImplicitMacro.scala</code>：</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ImplicitMacro</span> </span>{

  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PrettyShowUtil</span>[<span class="hljs-type">T</span>] </span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">String</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>)(<span class="hljs-keyword">implicit</span> prettyShowUtil: <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">String</span> =
    prettyShowUtil.show(x)
}</code></pre>
<p>这里定义了一个trait:<code>PrettyShowUtil</code>,这个trait里有一个<code>show</code>方法用于将某一类型的对象以某种字符串的形式返回回来。我们还在trait外面定应了一个<code>show</code>方法，用于简化<code>PrettyShowUtil</code>的<code>show</code>方法的调用，作用域内只要存在一个适当类型的<code>PrettyShowUtil</code>就能方便的调用<code>show</code>方法，这里创建一个测试文件<code>ImplicitMacro.scala</code>：</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> org.scalatest.funsuite.<span class="hljs-type">AnyFunSuite</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImplicitMacroTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>{
  <span class="hljs-keyword">import</span> <span class="hljs-type">ImplicitMacro</span>._
  test(<span class="hljs-string">""</span><span class="hljs-string">"class A will return a string "</span><span class="hljs-type">A</span>(someParam)<span class="hljs-string">" "</span><span class="hljs-string">""</span>) {
    <span class="hljs-comment">//重点代码开始</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-class">    <span class="hljs-title">implicit</span> <span class="hljs-title">val</span> <span class="hljs-title">aPrettyShowUtil</span> </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">A</span>] {
      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">A</span>): <span class="hljs-type">String</span> = <span class="hljs-string">s"A(<span class="hljs-subst">${x.value}</span>)"</span>
    }
    <span class="hljs-comment">//重点代码结束</span>
    assert(show(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(<span class="hljs-string">"hello"</span>)) == <span class="hljs-string">"A(hello)"</span>)
  }
}</code></pre>
<p>此时当我们出现一个类B的时候，又得在定义一个<code>PrettyShowUtil[A]</code>：</p>
<pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-class"><span class="hljs-title">implicit</span> <span class="hljs-title">val</span> <span class="hljs-title">aPrettyShowUtil</span> </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">A</span>] {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">A</span>): <span class="hljs-type">String</span> = <span class="hljs-string">s"A(<span class="hljs-subst">${x.value}</span>)"</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-class"><span class="hljs-title">implicit</span> <span class="hljs-title">val</span> <span class="hljs-title">bPrettyShowUtil</span> </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">B</span>] {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">B</span>): <span class="hljs-type">String</span> = <span class="hljs-string">s"B(<span class="hljs-subst">${x.value}</span>)"</span>
}</code></pre>
<p>此时我们可以使用隐式宏来解此问题，我们继续完善我们的<code>ImplicitMacro.scala</code>：</p>
<pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros

<span class="hljs-keyword">import</span> scala.language.experimental.macros
<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ImplicitMacro</span> </span>{

  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PrettyShowUtil</span>[<span class="hljs-type">T</span>] </span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">String</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>)(<span class="hljs-keyword">implicit</span> prettyShowUtil: <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">String</span> =
    prettyShowUtil.show(x)

  <span class="hljs-comment">//新增代码</span>
  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materialize</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">T</span>] =
    macro materializeImpl[<span class="hljs-type">T</span>]

  <span class="hljs-comment">//新增代码</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materializeImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](
      c: <span class="hljs-type">Context</span>
  ): c.<span class="hljs-type">Tree</span> = {
    <span class="hljs-keyword">import</span> c.universe._
    ???
  }
}</code></pre>
<p>我们把主要精力集中在<code>materializeImpl</code>方法上:</p>
<pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materializeImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](
      c: <span class="hljs-type">Context</span>
  ): c.<span class="hljs-type">Tree</span> = {
    <span class="hljs-keyword">import</span> c.universe._
    <span class="hljs-keyword">val</span> t = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]
    <span class="hljs-comment">//如对于类class A(val v1: String, val v2: Int),将转换成List(x.v1, x.v2)这种格式</span>
    <span class="hljs-keyword">val</span> paramValues = t.tpe.typeSymbol.asClass.primaryConstructor.asMethod
      .paramLists(<span class="hljs-number">0</span>)
      <span class="hljs-comment">// .map(param =&gt; q"x.$param")这种方式无法访问到param，因为这里是private类型的</span>
      .map(param =&gt; <span class="hljs-string">q"x.<span class="hljs-subst">${TermName(param.name.toString())}</span>"</span>)
    <span class="hljs-string">q""</span><span class="hljs-string">"</span>
<span class="hljs-string">    new PrettyShowUtil[$t] {</span>
<span class="hljs-string">      def show(x: $t): String = {</span>
<span class="hljs-string">        val paramsTemp = $paramValues</span>
<span class="hljs-string">        paramsTemp.mkString(${t.tpe.toString()} + "</span>(<span class="hljs-string">", "</span>, <span class="hljs-string">", "</span>)<span class="hljs-string">")</span>
<span class="hljs-string">      }</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">    "</span><span class="hljs-string">""</span>
  }</code></pre>
<p>在测试文件中添加测试方法:</p>
<pre><code class="hljs scala">test(<span class="hljs-string">" pretty show class by macro "</span>) {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span>, val value2: <span class="hljs-type">Int</span></span>)</span>
<span class="hljs-class">  <span class="hljs-title">val</span> <span class="hljs-title">value01</span> </span>= <span class="hljs-string">"yo,~"</span>
  <span class="hljs-keyword">val</span> value02 = <span class="hljs-number">2</span>
  assert(show(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(value01, value02)) == <span class="hljs-string">s"A(<span class="hljs-subst">$value01</span>, <span class="hljs-subst">$value02</span>)"</span>)
}</code></pre>
<h2 id="提取器宏"><a href="#提取器宏" class="headerlink" title="提取器宏"></a>提取器宏</h2><p>这部分没学好,求助各位网友给点资料学习，暂时没看出来比普通提取器强大在哪里，直接附上<a target="_blank" rel="noopener" href="https://docs.scala-lang.org/overviews/macros/extractors.html">官方文档地址</a>吧，留个坑以后填。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-small is-default py-4" href="/chuanblog.github.io/2022/01/29/arch%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98/" title="arch配置及问题"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: arch配置及问题</span></a><a class="button is-small is-default py-4" href="/chuanblog.github.io/2021/01/29/scala%E5%AE%8F%E7%AC%94%E8%AE%B0/" title="scala宏笔记"><span class="has-text-weight-semibold">Next: scala宏笔记</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="chuanzhangjiang/chuanblog.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/chuanzhangjiang"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/zhang-chuan-72-58"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> chuan 2022</span></p><div class="is-flex"><p>Powered by Hexo｜</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by &nbspHaojen&nbsp</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/chuanblog.github.io/js/post.js"></script></body></html>