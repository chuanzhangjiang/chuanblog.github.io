<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-30T14:42:18.400Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>arch系统备份和还原</title>
    <link href="http://example.com/2022/01/30/arch%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/"/>
    <id>http://example.com/2022/01/30/arch%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/</id>
    <published>2022-01-30T12:25:42.000Z</published>
    <updated>2022-01-30T14:42:18.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只备份根分区, home分区直接将重要文件拷贝下来即可。</p><h2 id="安装pigz"><a href="#安装pigz" class="headerlink" title="安装pigz"></a>安装pigz</h2><pre><code class="hljs plain">$ pacman -S pigz</code></pre><h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><pre><code class="hljs plain">$ pacman -Sc</code></pre><h2 id="在-config目录下创建不备份目录列表"><a href="#在-config目录下创建不备份目录列表" class="headerlink" title="在~/.config目录下创建不备份目录列表"></a>在<code>~/.config</code>目录下创建不备份目录列表</h2><pre><code class="hljs plain">$ emacs ~/.config/exclude</code></pre><p>加入如下内容</p><pre><code class="hljs plain">/proc/*/dev/*/sys/*/tmp/*/mnt/*/media/*/run/*/var/lock/*/var/run/*/var/lib/pacman/*/var/cache/pacman/pkg/*/lost+found</code></pre><h2 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h2><p>将根分区备份到home分区中的<code>backup/root-backup.tgz</code>中：</p><pre><code class="hljs plain">$ sudo tar --use-compress-program=pigz -cvpf ~/backup/root-backup.tgz --exclude-from=/home/chuan/.config/exclude /</code></pre><h2 id="使用liveCD进入系统"><a href="#使用liveCD进入系统" class="headerlink" title="使用liveCD进入系统"></a>使用liveCD进入系统</h2><h2 id="格式化根分区和boot分区"><a href="#格式化根分区和boot分区" class="headerlink" title="格式化根分区和boot分区"></a>格式化根分区和boot分区</h2><pre><code class="hljs plain"># mkfs.ext4 /dev/root_partition# mkfs.fat -F 32 /dev/efi_system_partition</code></pre><h2 id="挂载根分区和home分区"><a href="#挂载根分区和home分区" class="headerlink" title="挂载根分区和home分区"></a>挂载根分区和home分区</h2><pre><code class="hljs plain"># mkdir /mnt/root# mkdir /mnt/home# mount /dev/root_partition /mnt/root# mount /dev/home_partition /mnt/home</code></pre><h2 id="在liveCD中安装pigz"><a href="#在liveCD中安装pigz" class="headerlink" title="在liveCD中安装pigz"></a>在liveCD中安装pigz</h2><h2 id="解压home分区下的根分区备份文件到根分区中"><a href="#解压home分区下的根分区备份文件到根分区中" class="headerlink" title="解压home分区下的根分区备份文件到根分区中"></a>解压home分区下的根分区备份文件到根分区中</h2><pre><code class="hljs plain"># tar --use-compress-program=pigz -xvpf /mnt/home/chuan/backup/root-backup.tgz -C /mnt/root/</code></pre><h2 id="取消挂载"><a href="#取消挂载" class="headerlink" title="取消挂载"></a>取消挂载</h2><pre><code class="hljs plain"># umount /mnt/root# umount /mnt/home</code></pre><h2 id="删除root目录"><a href="#删除root目录" class="headerlink" title="删除root目录"></a>删除root目录</h2><pre><code class="hljs plain"># rm -r /mnt/root</code></pre><h2 id="重新按照linux结构挂载"><a href="#重新按照linux结构挂载" class="headerlink" title="重新按照linux结构挂载"></a>重新按照linux结构挂载</h2><pre><code class="hljs plain"># mount /dev/root_partition /mnt# mount /dev/home_partition /home# mount /dev/efi_partition /boot</code></pre><h2 id="开启swap"><a href="#开启swap" class="headerlink" title="开启swap"></a>开启swap</h2><pre><code class="hljs plain"># swapon /dev/swap_partition</code></pre><h2 id="重新生成fstab"><a href="#重新生成fstab" class="headerlink" title="重新生成fstab"></a>重新生成fstab</h2><pre><code class="hljs plain"># genfstab -U /mnt &gt; /mnt/etc/fstab</code></pre><h2 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h2><pre><code class="hljs plain"># arch-chroot /mnt</code></pre><h2 id="重新配置bootloader"><a href="#重新配置bootloader" class="headerlink" title="重新配置bootloader"></a>重新配置bootloader</h2><pre><code class="hljs plain"># grub-mkconfig -o /boot/grub/grub.cfg</code></pre><h2 id="重启进入系统"><a href="#重启进入系统" class="headerlink" title="重启进入系统"></a>重启进入系统</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;只备份根分区, home分区直接将重要文件拷贝下来即可。&lt;/p&gt;
&lt;h2 id=&quot;安装pigz&quot;&gt;&lt;a href=&quot;#安装pigz&quot; cla</summary>
      
    
    
    
    
    <category term="arch" scheme="http://example.com/tags/arch/"/>
    
    <category term="备份还原" scheme="http://example.com/tags/%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>arch配置及问题</title>
    <link href="http://example.com/2022/01/29/arch%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/01/29/arch%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-29T12:56:12.000Z</published>
    <updated>2022-01-30T13:00:16.993Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%AE%89%E8%A3%85%E5%8F%8A%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">安装及网络配置</a></li><li><a href="#%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83">桌面环境</a></li><li><a href="#%E5%AE%89%E8%A3%85nerd%E5%AD%97%E4%BD%93">安装nerd字体</a></li><li><a href="#%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93">安装中文字体</a></li><li><a href="#%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95">安装中文输入法</a></li><li><a href="#%E5%AE%89%E8%A3%85chrome">安装chrome</a></li><li><a href="#%E4%BF%AE%E6%94%B9zprofile%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%A8%8B%E5%BA%8F">修改<code>~/.zprofile</code>中的默认程序</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%83%8C%E5%85%B3%E7%81%AF%E8%B0%83%E8%8A%82%E8%BD%AF%E4%BB%B6">修改笔记本背关灯调节软件</a></li><li><a href="#%E6%A0%B9%E6%8D%AE%E5%96%9C%E5%A5%BD%E4%BF%AE%E6%94%B9dwmblocks">根据喜好修改<code>dwmblocks</code></a></li><li><a href="#%E5%AE%89%E8%A3%85wal%E5%AE%9E%E7%8E%B0%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2%E6%A0%B9%E6%8D%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E6%94%B9%E5%8F%98">安装<code>wal</code>实现主题配色根据背景图片改变</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84dwm">使用自己修改过的dwm</a></li><li><a href="#%E5%AE%89%E8%A3%85java">安装java</a></li><li><a href="#%E5%AE%89%E8%A3%85sbt">安装sbt</a></li><li><a href="#%E5%AE%89%E8%A3%85vscode">安装vscode</a></li></ul><h2 id="安装及网络配置"><a href="#安装及网络配置" class="headerlink" title="安装及网络配置"></a>安装及网络配置</h2><p>安装直接而参照<a href="https://wiki.archlinux.org/title/installation_guide">官方文档</a>，bootload参考<a href="https://lapherder.tech/index.php/archives/10/">此处</a>，网络配置<a href="https://lapherder.tech/index.php/archives/11/">参考</a>。</p><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><p>直接使用luke的larbs脚本自动<a href="https://larbs.xyz/">配置</a>。</p><pre><code class="hljs plain">$ curl -LO larbs.xyz/larbs.sh$ sh larbs.sh</code></pre><h2 id="安装nerd字体"><a href="#安装nerd字体" class="headerlink" title="安装nerd字体"></a>安装nerd字体</h2><pre><code class="hljs plain">$ yay -S nerd-fonts-complete</code></pre><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><pre><code class="hljs plain">$ yay -S noto-fonts-cjk</code></pre><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><p>首先</p><pre><code class="hljs plain">$ yay -S fcitx5-im //输入法框架$ yay -S fcitx5-chinese-addons //中文输入法插件</code></pre><p>然后，启动fcitx5-config进行配置；</p><p>接下来，配置fcitx5开机自启动，在家目录下.xprofile中加入:</p><pre><code class="hljs plain">fcitx5 -d</code></pre><p>最后<code>~/.pam_environment</code>中加入如下环境变量，保证某些程序正常启动输入法:</p><pre><code class="hljs plain">GTK_IM_MODULE DEFAULT=fcitxQT_IM_MODULE  DEFAULT=fcitxXMODIFIERS    DEFAULT=\@im=fcitxINPUT_METHOD  DEFAULT=fcitxSDL_IM_MODULE DEFAULT=fcitxGLFW_IM_MODULE DEFAULT=ibus</code></pre><h2 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h2><pre><code class="hljs plain">$ yay -S google-chrome</code></pre><h2 id="修改-zprofile中的默认程序"><a href="#修改-zprofile中的默认程序" class="headerlink" title="修改~/.zprofile中的默认程序"></a>修改<code>~/.zprofile</code>中的默认程序</h2><h2 id="修改笔记本背关灯调节软件"><a href="#修改笔记本背关灯调节软件" class="headerlink" title="修改笔记本背关灯调节软件"></a>修改笔记本背关灯调节软件</h2><p>首先替换原先使用的软件：</p><pre><code class="hljs plain">$ yay -S acpilight</code></pre><p>定位<code>xbacklight</code>位置:</p><pre><code class="hljs plain">$ whic xbacklight</code></pre><p>根据输出修改visudo</p><pre><code class="hljs plain">$ sudo SUDO_EDITOR=emacs visudo</code></pre><h2 id="根据喜好修改dwmblocks"><a href="#根据喜好修改dwmblocks" class="headerlink" title="根据喜好修改dwmblocks"></a>根据喜好修改<code>dwmblocks</code></h2><p>修改状态栏显示内容，位置:<code>~/.local/src/dwmblocks/config.h</code>，修改完后编译安装:</p><pre><code class="hljs plain">$ sudo make clean install</code></pre><h2 id="安装wal实现主题配色根据背景图片改变"><a href="#安装wal实现主题配色根据背景图片改变" class="headerlink" title="安装wal实现主题配色根据背景图片改变"></a>安装<code>wal</code>实现主题配色根据背景图片改变</h2><pre><code class="hljs plain">$ yay -S wal</code></pre><p>将~/.xprofile中的<code>setbg &amp;</code>改为<code>setbg</code>, 使得dwm也启用主题配色。<br><strong>note: 修改背景图片，使用lf选中对应图片，按b。</strong></p><h2 id="使用自己修改过的dwm"><a href="#使用自己修改过的dwm" class="headerlink" title="使用自己修改过的dwm"></a>使用自己修改过的dwm</h2><p>仓库地址:<a href="mailto:git@github.com">git@github.com</a>:chuanzhangjiang/dwm-luke.git</p><h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><h2 id="安装sbt"><a href="#安装sbt" class="headerlink" title="安装sbt"></a>安装sbt</h2><h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85%E5%8F%8A%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE&quot;&gt;安装及网络配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A1%8C%E9%9D%A2%E7%8E%</summary>
      
    
    
    
    
    <category term="arch" scheme="http://example.com/tags/arch/"/>
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>scala宏学习文档</title>
    <link href="http://example.com/2021/02/01/scala%E5%AE%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/02/01/scala%E5%AE%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</id>
    <published>2021-02-01T13:55:29.000Z</published>
    <updated>2022-01-30T06:19:12.126Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE">创建测试项目</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AE%8F%E5%87%BD%E6%95%B0">定义一个宏函数</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91ast%E5%92%8Cq%E6%8F%92%E5%80%BC%E5%99%A8">抽象语法树(AST)和q插值器</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E5%85%B7%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E6%96%B9%E6%B3%95">定义具有类型参数的宏方法</a></li><li><a href="#%E4%BD%BF%E7%94%A8macro-bundle%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%AE%8F">使用macro bundle的方式定义宏</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E5%AE%8F">定义隐式宏</a></li><li><a href="#%E6%8F%90%E5%8F%96%E5%99%A8%E5%AE%8F">提取器宏</a></li><li><a href="#"></a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文适用于scala 2.13.x版本。</p><h2 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h2><p>由于宏和测试用代码不能存在于同一个编译环境下，故使用sbt创建一个主项目，然后在主项目中创建子项目，用来存放宏代码,下面开始干。</p><p>首先，创建项目目录,进入项目目录：</p><pre><code class="hljs plain">$ mkdir macro-doc-sample$ cd macro-doc-sample</code></pre><p>新建build.sbt文件：</p><pre><code class="hljs plain">$ touch build.sbt</code></pre><p>打开build.sbt输入如下配置：</p><pre><code class="hljs scala"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> scalav = <span class="hljs-string">"2.13.3"</span><span class="hljs-comment">// 所有项目的公用配置</span><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> commonSettings = <span class="hljs-type">Seq</span>(  scalaVersion := scalav,  organization := <span class="hljs-string">"me.zjc"</span>)<span class="hljs-comment">//scala宏在scala反射库中，需要手动引入</span><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> scalaReflect = <span class="hljs-string">"org.scala-lang"</span> % <span class="hljs-string">"scala-reflect"</span> % scalav<span class="hljs-comment">// 根目录项目</span><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root = (project in file(<span class="hljs-string">"."</span>))  .dependsOn(macros)  .settings(    name := <span class="hljs-string">"macro-doc-sample"</span>,    commonSettings  )<span class="hljs-comment">// 宏项目</span><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> macros = (project in file(<span class="hljs-string">"macros"</span>))  .settings(    name := <span class="hljs-string">"macros"</span>,    commonSettings,    libraryDependencies += scalaReflect  )</code></pre><p>使用sbt加载项目：</p><pre><code class="hljs plain">$ sbt</code></pre><p>加载完毕，在两个项目中分别创建源码文件夹：</p><pre><code class="hljs plain">$ mkdir -p src/main/scala/me/zjc/macrodocsample$ mkdir -p macros/src/main/scala/me/zjc/macros</code></pre><p>OK，可以开始写宏了！</p><h2 id="定义一个宏函数"><a href="#定义一个宏函数" class="headerlink" title="定义一个宏函数"></a>定义一个宏函数</h2><p>在macro项目源码目录新建文件HelloMacro.scala，输入如下代码:</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span><span class="hljs-keyword">import</span> scala.language.experimental.macros<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloMacro</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span></span>(msg: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = macro helloImpl  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-keyword">val</span> result = <span class="hljs-string">q""</span><span class="hljs-string">"println("</span>hello <span class="hljs-string">" + $msg)"</span><span class="hljs-string">""</span>    c.<span class="hljs-type">Expr</span>(result)  }}</code></pre><p>首先来看开头导入的<code>scala.reflect.macros.whitebox.Context</code>和<code>scala.language.experimental.macros</code>，导入前者是为了可以使用宏环境(Context),宏环境可以理解为宏在运行时所以依赖的环境，编写宏需要从这个环境中获取各种各样的信息，宏还可以通过这个环境中反馈一些信息给用户，环境分为白盒环境(whitebox.Context)和黑盒环境(blackbox.Context),具体区别以后在说，目前不做讨论。导入后者是为了能正常使用<code>macro</code>关键字。</p><p>接下来看两个方法<code>Hello</code>和<code>HelloImpl</code>,我们写好宏之后，我们只调用<code>hello</code>方法，并不会去直接使用<code>HelloImpl</code>方法,使用<code>hello</code>方法就像调用普通的方法一样：</p><pre><code class="hljs scala"><span class="hljs-type">HelloMacro</span>.hello(<span class="hljs-string">"macro"</span>)</code></pre><p>在编译器编译之后，会对上面的方法进行宏展开，所以在我们眼里代码是长上面这个样子的，但是在JVM眼中，代码长下面这个样子：</p><pre><code class="hljs scala">println(<span class="hljs-string">"hello "</span> + <span class="hljs-string">"macro"</span>)</code></pre><p>OK，现在我们来观察<code>helloImpl</code>,顾名思义，这是<code>hello</code>宏方法的具体实现，定义<code>helloImpl</code>方法是讲究格式的，第一个参数必须是<code>Context</code>宏环境，第二个参数必须和<code>hello</code>方法的第一个参数同名，如果<code>hello</code>有多个参数依次类推，这些参数的类型需要为<code>c.Expr[hello方法参数对应类型]</code>，返回类型<code>c.Expr[hello方法返回值类型]</code>,当然，如果你想图方便可以将参数类型和返回类型统一设置为<code>c.Tree</code>。</p><h2 id="抽象语法树-AST-和q插值器"><a href="#抽象语法树-AST-和q插值器" class="headerlink" title="抽象语法树(AST)和q插值器"></a>抽象语法树(AST)和q插值器</h2><p>开始写宏的具体实现之前我们需要对scala的抽象语法树和q插值器进行介绍,抽象语法树即代码树，是代码的树型表示法，打个比方，一个简单的代码片段：</p><pre><code class="hljs plain">AObjct.bFunc()</code></pre><p>转换为抽象语法树之后将会变为如下：</p><pre><code class="hljs plain">Apply(Select(Ident(TermName("AObjct")), TermName("bFunc")), List())</code></pre><p>本质是，scala2版本的宏就是对着上面这玩意儿编程，我们在把目光放到<code>helloImpl</code>方法上,它接收一个参数<code>msg: c.Expr[String]</code>,其实他本质上接收的就是一个抽象语法树，比如当我们给<code>hello</code>方法传入<code>"macro"</code>时，<code>helloImpl</code>方法接受到的参数长这样:</p><pre><code class="hljs plain">Literal(Constant("macro"))</code></pre><p>聪明的你可能已经注意到，<code>helloImpl</code>方法的返回值依然是一个<code>c.Expr[Unit]</code>,所以当我们想要让<code>hello</code>方法宏展开之后变为<code>println("hello macro")</code>的话，我们就需要将<code>println("hello macro")</code>变成一颗抽象语法树返回回来，它的语法树长这样:</p><pre><code class="hljs scala"><span class="hljs-type">Apply</span>(<span class="hljs-type">Ident</span>(<span class="hljs-type">TermName</span>(<span class="hljs-string">"println"</span>)), <span class="hljs-type">List</span>(<span class="hljs-type">Literal</span>(<span class="hljs-type">Constant</span>(<span class="hljs-string">"hello macro"</span>))))</code></pre><p>所以<code>helloImpl</code>方法应该长这样:</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {  <span class="hljs-keyword">import</span> c.universe._  <span class="hljs-keyword">val</span> tree =    <span class="hljs-type">Apply</span>(<span class="hljs-type">Ident</span>(<span class="hljs-type">TermName</span>(<span class="hljs-string">"println"</span>)), <span class="hljs-type">List</span>(<span class="hljs-type">Literal</span>(<span class="hljs-type">Constant</span>(<span class="hljs-string">"hello macro"</span>))))  c.<span class="hljs-type">Expr</span>(tree)}</code></pre><p>好的，我们新建一个Main(src/main/scala/me/zjc/macrodocsample/Main.scala)对象测试一下：</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macrodocsample<span class="hljs-keyword">import</span> me.zjc.macros.<span class="hljs-type">HelloMacro</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{  <span class="hljs-type">HelloMacro</span>.hello(<span class="hljs-string">""</span>)}</code></pre><p>使用sbt运行项目:</p><pre><code class="hljs plain">$ sbt$ run</code></pre><p>不出意外可以成功打印”hello macro”,上面的例子并没有运用上传入参数msg，就已经让人头疼了，更何况以后更复杂的情况。所以q插值器出现了，上面的例子如果使用q插值器，将会变成你所熟悉的样子：</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {  <span class="hljs-keyword">import</span> c.universe._  <span class="hljs-keyword">val</span> tree = <span class="hljs-string">q""</span><span class="hljs-string">"println("</span>hello <span class="hljs-string">macro")"</span><span class="hljs-string">""</span>  c.<span class="hljs-type">Expr</span>(tree)}</code></pre><p>再次运行项目，得到同样的结果，此时我们还可以将msg参数代入到抽象语法树中:</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloImpl</span></span>(c: <span class="hljs-type">Context</span>)(msg: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>]): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>] = {  <span class="hljs-keyword">import</span> c.universe._  <span class="hljs-keyword">val</span> tree = <span class="hljs-string">q""</span><span class="hljs-string">"println("</span>hello <span class="hljs-string">" + $msg)"</span><span class="hljs-string">""</span>  c.<span class="hljs-type">Expr</span>(tree)}</code></pre><p>q插值器可以将我们输入的字符串转换成抽象语法树，就是这么神奇。具体的q插值器的使用还可以参考翔一样的<a href="https://docs.scala-lang.org/overviews/quasiquotes/intro.html">官方文档。</a></p><h2 id="定义具有类型参数的宏方法"><a href="#定义具有类型参数的宏方法" class="headerlink" title="定义具有类型参数的宏方法"></a>定义具有类型参数的宏方法</h2><p>我们在macro子项目中新建文件<code>MacroWithType.scala</code>:</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> scala.language.experimental.macros<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroWithType</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNonParamObj</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">T</span> = macro getNonParamObjImpl[<span class="hljs-type">T</span>]  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNonParamObjImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](c: <span class="hljs-type">Context</span>): c.<span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>] = {    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-keyword">val</span> t = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]    <span class="hljs-keyword">val</span> result = <span class="hljs-string">q"new <span class="hljs-subst">$t</span>()"</span>    c.<span class="hljs-type">Expr</span>(result)  }}</code></pre><p>定义impl方法时候加入bundle context参数<code>c.WeakTypeTag</code>即可，使用上面的例子可以用来实例化所有构造器可以不需要传入参数的类，我们可以来测试一下，下面我们用scalaTest来测试我们的代码,加入scalaTest依赖:</p><pre><code class="hljs scala"><span class="hljs-comment">// 宏项目</span><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> macros = (project in file(<span class="hljs-string">"macros"</span>))  .settings(    name := <span class="hljs-string">"macros"</span>,    commonSettings,    libraryDependencies ++= <span class="hljs-type">Seq</span>(      scalaReflect,      <span class="hljs-string">"org.scalatest"</span> %% <span class="hljs-string">"scalatest"</span> % <span class="hljs-string">"3.2.2"</span> % <span class="hljs-string">"test"</span>    )  )</code></pre><p>创建测试目录<code>macros/src/test/scala/me/zjc/macros/</code>,新建文件<code>MacroWithTypeTest.scala</code>:</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> org.scalatest.funsuite.<span class="hljs-type">AnyFunSuite</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroWithTypeTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>{  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span><span class="hljs-class">  <span class="hljs-title">test</span>(<span class="hljs-params">"generate a no param constructor class <span class="hljs-type">A</span>"</span>) </span>{    <span class="hljs-keyword">val</span> a = <span class="hljs-type">MacroWithType</span>.getNonParamObj[<span class="hljs-type">A</span>]    assert(a.isInstanceOf[<span class="hljs-type">A</span>])  }}</code></pre><p>运行测试:</p><pre><code class="hljs plain">$ sbt$ project macros$ test</code></pre><p>不出意外将会看见all tests passed。</p><h2 id="使用macro-bundle的方式定义宏"><a href="#使用macro-bundle的方式定义宏" class="headerlink" title="使用macro bundle的方式定义宏"></a>使用macro bundle的方式定义宏</h2><p>因为比较好理解，直接show code，创建<code>MacroWithBundle.scala</code>:</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> scala.language.experimental.macros<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroWithBundle</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroWithBundleFunc</span></span>: <span class="hljs-type">String</span> = macro <span class="hljs-type">Macros</span>.impl  <span class="hljs-comment">// 这就是macro bundle</span>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Macros</span>(<span class="hljs-params">val /*这个val不能漏掉*/ c: <span class="hljs-type">Context</span></span>) </span>{    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">impl</span></span>: c.<span class="hljs-type">Expr</span>[<span class="hljs-type">String</span>] = {      <span class="hljs-keyword">val</span> resultStr = <span class="hljs-string">"hello macro"</span>      c.<span class="hljs-type">Expr</span>(<span class="hljs-string">q""</span><span class="hljs-string">"$resultStr"</span><span class="hljs-string">""</span>)    }  }}</code></pre><p>测试代码:</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> org.scalatest.funsuite.<span class="hljs-type">AnyFunSuite</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroWithBundleTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>{  test(<span class="hljs-string">""</span><span class="hljs-string">"invok macro method will get a String value "</span>hello <span class="hljs-string">macro" "</span><span class="hljs-string">""</span>) {    assert(<span class="hljs-type">MacroWithBundle</span>.macroWithBundleFunc == <span class="hljs-string">"hello macro"</span>)  }}</code></pre><h2 id="定义隐式宏"><a href="#定义隐式宏" class="headerlink" title="定义隐式宏"></a>定义隐式宏</h2><p>新建一个文件<code>ImplicitMacro.scala</code>：</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ImplicitMacro</span> </span>{  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PrettyShowUtil</span>[<span class="hljs-type">T</span>] </span>{    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">String</span>  }  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>)(<span class="hljs-keyword">implicit</span> prettyShowUtil: <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">String</span> =    prettyShowUtil.show(x)}</code></pre><p>这里定义了一个trait:<code>PrettyShowUtil</code>,这个trait里有一个<code>show</code>方法用于将某一类型的对象以某种字符串的形式返回回来。我们还在trait外面定应了一个<code>show</code>方法，用于简化<code>PrettyShowUtil</code>的<code>show</code>方法的调用，作用域内只要存在一个适当类型的<code>PrettyShowUtil</code>就能方便的调用<code>show</code>方法，这里创建一个测试文件<code>ImplicitMacro.scala</code>：</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> org.scalatest.funsuite.<span class="hljs-type">AnyFunSuite</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImplicitMacroTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>{  <span class="hljs-keyword">import</span> <span class="hljs-type">ImplicitMacro</span>._  test(<span class="hljs-string">""</span><span class="hljs-string">"class A will return a string "</span><span class="hljs-type">A</span>(someParam)<span class="hljs-string">" "</span><span class="hljs-string">""</span>) {    <span class="hljs-comment">//重点代码开始</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span></span>)</span><span class="hljs-class">    <span class="hljs-title">implicit</span> <span class="hljs-title">val</span> <span class="hljs-title">aPrettyShowUtil</span> </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">A</span>] {      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">A</span>): <span class="hljs-type">String</span> = <span class="hljs-string">s"A(<span class="hljs-subst">${x.value}</span>)"</span>    }    <span class="hljs-comment">//重点代码结束</span>    assert(show(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(<span class="hljs-string">"hello"</span>)) == <span class="hljs-string">"A(hello)"</span>)  }}</code></pre><p>此时当我们出现一个类B的时候，又得在定义一个<code>PrettyShowUtil[A]</code>：</p><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span></span>)</span><span class="hljs-class"><span class="hljs-title">implicit</span> <span class="hljs-title">val</span> <span class="hljs-title">aPrettyShowUtil</span> </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">A</span>] {  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">A</span>): <span class="hljs-type">String</span> = <span class="hljs-string">s"A(<span class="hljs-subst">${x.value}</span>)"</span>}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span></span>)</span><span class="hljs-class"><span class="hljs-title">implicit</span> <span class="hljs-title">val</span> <span class="hljs-title">bPrettyShowUtil</span> </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">B</span>] {  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">B</span>): <span class="hljs-type">String</span> = <span class="hljs-string">s"B(<span class="hljs-subst">${x.value}</span>)"</span>}</code></pre><p>此时我们可以使用隐式宏来解此问题，我们继续完善我们的<code>ImplicitMacro.scala</code>：</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> me.zjc.macros<span class="hljs-keyword">import</span> scala.language.experimental.macros<span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ImplicitMacro</span> </span>{  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PrettyShowUtil</span>[<span class="hljs-type">T</span>] </span>{    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">String</span>  }  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>)(<span class="hljs-keyword">implicit</span> prettyShowUtil: <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">String</span> =    prettyShowUtil.show(x)  <span class="hljs-comment">//新增代码</span>  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materialize</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">PrettyShowUtil</span>[<span class="hljs-type">T</span>] =    macro materializeImpl[<span class="hljs-type">T</span>]  <span class="hljs-comment">//新增代码</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materializeImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](      c: <span class="hljs-type">Context</span>  ): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    ???  }}</code></pre><p>我们把主要精力集中在<code>materializeImpl</code>方法上:</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materializeImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](      c: <span class="hljs-type">Context</span>  ): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-keyword">val</span> t = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]    <span class="hljs-comment">//如对于类class A(val v1: String, val v2: Int),将转换成List(x.v1, x.v2)这种格式</span>    <span class="hljs-keyword">val</span> paramValues = t.tpe.typeSymbol.asClass.primaryConstructor.asMethod      .paramLists(<span class="hljs-number">0</span>)      <span class="hljs-comment">// .map(param =&gt; q"x.$param")这种方式无法访问到param，因为这里是private类型的</span>      .map(param =&gt; <span class="hljs-string">q"x.<span class="hljs-subst">${TermName(param.name.toString())}</span>"</span>)    <span class="hljs-string">q""</span><span class="hljs-string">"</span><span class="hljs-string">    new PrettyShowUtil[$t] {</span><span class="hljs-string">      def show(x: $t): String = {</span><span class="hljs-string">        val paramsTemp = $paramValues</span><span class="hljs-string">        paramsTemp.mkString(${t.tpe.toString()} + "</span>(<span class="hljs-string">", "</span>, <span class="hljs-string">", "</span>)<span class="hljs-string">")</span><span class="hljs-string">      }</span><span class="hljs-string">    }</span><span class="hljs-string">    "</span><span class="hljs-string">""</span>  }</code></pre><p>在测试文件中添加测试方法:</p><pre><code class="hljs scala">test(<span class="hljs-string">" pretty show class by macro "</span>) {  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">val value: <span class="hljs-type">String</span>, val value2: <span class="hljs-type">Int</span></span>)</span><span class="hljs-class">  <span class="hljs-title">val</span> <span class="hljs-title">value01</span> </span>= <span class="hljs-string">"yo,~"</span>  <span class="hljs-keyword">val</span> value02 = <span class="hljs-number">2</span>  assert(show(<span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(value01, value02)) == <span class="hljs-string">s"A(<span class="hljs-subst">$value01</span>, <span class="hljs-subst">$value02</span>)"</span>)}</code></pre><h2 id="提取器宏"><a href="#提取器宏" class="headerlink" title="提取器宏"></a>提取器宏</h2><p>这部分没学好,求助各位网友给点资料学习，暂时没看出来比普通提取器强大在哪里，直接附上<a href="https://docs.scala-lang.org/overviews/macros/extractors.html">官方文档地址</a>吧，留个坑以后填。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E8%A8%80&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE&quot;&gt;创建测试项目&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="scala" scheme="http://example.com/tags/scala/"/>
    
    <category term="宏" scheme="http://example.com/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>scala宏笔记</title>
    <link href="http://example.com/2021/01/29/scala%E5%AE%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/01/29/scala%E5%AE%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-29T06:59:25.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是备忘录，除非你时间很多，否则不建议你阅读。</p><h2 id="宏代码和测试代码不能在同一个编译环境中"><a href="#宏代码和测试代码不能在同一个编译环境中" class="headerlink" title="宏代码和测试代码不能在同一个编译环境中"></a>宏代码和测试代码不能在同一个编译环境中</h2><p><a href="https://www.scala-sbt.org/1.x/docs/Macro-Projects.html">sbt宏项目</a></p><h2 id="定义宏函数"><a href="#定义宏函数" class="headerlink" title="定义宏函数"></a>定义宏函数</h2><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.language.experimental.macros <span class="hljs-comment">//使得函数体可以使用macro做前缀</span><span class="hljs-keyword">import</span> scala.reflect.macros.whitebox.<span class="hljs-type">Context</span> <span class="hljs-comment">//宏所需的环境</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroTest</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTest</span></span>(input: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = macro macroTestImpl  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTestImpl</span></span>(c: <span class="hljs-type">Context</span>)(input: c.<span class="hljs-type">Tree</span>): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-string">q"println(<span class="hljs-subst">$input</span>)"</span>  }}</code></pre><p>宏函数<code>macroTest</code>调用了他的实现<code>macroTestImpl</code>,<code>macroTestImpl</code>格式需要注意两点，参数<code>c: Context</code>必须作为地一个参数传入，独占一个括号;第二个括号中的参数必须和宏函数<code>macroTest</code>的第一个括号中的参数一一对应，对应原则：参数名必须相同，参数类型统一替换为<code>c.Tree</code>(c.Expr[_]的情况暂不讨论)。</p><p>下面是几种定义样例</p><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroTest</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTest</span></span>[<span class="hljs-type">T</span>](input: <span class="hljs-type">String</span>, input2: <span class="hljs-type">Any</span>): <span class="hljs-type">T</span> = macro macroTestImpl[<span class="hljs-type">T</span>]  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTestImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](      c: <span class="hljs-type">Context</span>  )(input: c.<span class="hljs-type">Tree</span>, input2: c.<span class="hljs-type">Tree</span>): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    ???  }}</code></pre><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroTest</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTest</span></span>(input: <span class="hljs-type">String</span>*): <span class="hljs-type">Unit</span> = macro macroTestImpl  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTestImpl</span></span>(      c: <span class="hljs-type">Context</span>  )(input: c.<span class="hljs-type">Tree</span>*): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    ???  }}</code></pre><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroTest</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTest</span></span>(input: <span class="hljs-type">String</span>)(input2: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = macro macroTestImpl  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTestImpl</span></span>(      c: <span class="hljs-type">Context</span>  )(input: c.<span class="hljs-type">Tree</span>)(input2: c.<span class="hljs-type">Tree</span>): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    ???  }}</code></pre><h2 id="关于Tree"><a href="#关于Tree" class="headerlink" title="关于Tree"></a>关于<code>Tree</code></h2><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><code>a.b</code>相当于对应<code>Select（a, b）</code></p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><code>a(b)</code>相当于<code>Apply(a, List(b))</code></p><h3 id="常量表示"><a href="#常量表示" class="headerlink" title="常量表示"></a>常量表示</h3><p><code>Literal(Constant("hello"))</code></p><h3 id="变量表示"><a href="#变量表示" class="headerlink" title="变量表示"></a>变量表示</h3><p><code>TermName("a")</code></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可以使用<code>showRaw</code>方法打赢<code>q</code>插值器的内容查看各种对应关系。</p><h2 id="写宏速查"><a href="#写宏速查" class="headerlink" title="写宏速查"></a>写宏速查</h2><h3 id="获取传入类型参数的类型"><a href="#获取传入类型参数的类型" class="headerlink" title="获取传入类型参数的类型"></a>获取传入类型参数的类型</h3><pre><code class="hljs scala"><span class="hljs-keyword">val</span> t: c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>] = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]</code></pre><h3 id="判断一个类是否是case类型"><a href="#判断一个类是否是case类型" class="headerlink" title="判断一个类是否是case类型"></a>判断一个类是否是case类型</h3><p>使用<code>ClassSymbol.isCaseClass</code>,比如从<code>t: c.WeakTypeTag[T]</code>中获取该类型是否是caseClass：</p><pre><code class="hljs scala">t.tpe.typeSymbol.asClass.isCaseClass</code></pre><h3 id="获取某个类的伴生对象对应的symbol"><a href="#获取某个类的伴生对象对应的symbol" class="headerlink" title="获取某个类的伴生对象对应的symbol"></a>获取某个类的伴生对象对应的symbol</h3><p>使用<code>ClassSymbol.companion</code>,比如从<code>t: c.WeakTypeTag[T]</code>中获取该类对应的伴生对象:</p><pre><code class="hljs scala">t.tpe.typeSymbol.asClass.companion</code></pre><h3 id="获取某个类的主构造其symbol"><a href="#获取某个类的主构造其symbol" class="headerlink" title="获取某个类的主构造其symbol"></a>获取某个类的主构造其symbol</h3><p>使用<code>ClassSymbol.primaryConstructor</code>,比如从<code>t: c.WeakTypeTag[T]</code>中获取该类对应的主构造器:</p><pre><code class="hljs scala">t.tpe.typeSymbol.asClass.primaryConstructor</code></pre><h3 id="获取方法的参数"><a href="#获取方法的参数" class="headerlink" title="获取方法的参数"></a>获取方法的参数</h3><p>使用<code>MethodSymbol.paramLists</code></p><h3 id="获取方法中的参数是否存在默认值"><a href="#获取方法中的参数是否存在默认值" class="headerlink" title="获取方法中的参数是否存在默认值"></a>获取方法中的参数是否存在默认值</h3><p>使用<code>TermSymbol.isParamWithDefault</code>,如将<code>t: c.WeakTypeTag[T]</code>的主构造器中存在默认值的参数的名字存入List中返回回来：</p><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MacroTest</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTest</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = macro macroTestImpl[<span class="hljs-type">T</span>]  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">macroTestImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](c: <span class="hljs-type">Context</span>): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-keyword">val</span> t = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]    <span class="hljs-keyword">val</span> defaultParamNameList =      t.tpe.typeSymbol.asClass.primaryConstructor.asMethod.paramLists.flatten        .filter(_.asTerm.isParamWithDefault)        .map(_.asTerm.name.toString())    <span class="hljs-string">q""</span><span class="hljs-string">"</span><span class="hljs-string">    List(..$defaultParamNameList)</span><span class="hljs-string">    "</span><span class="hljs-string">""</span>  }}</code></pre><p>使用</p><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> </span>{  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">normal1: <span class="hljs-type">String</span>, default: <span class="hljs-type">String</span> = "a", default2: <span class="hljs-type">Int</span> = 2</span>)</span><span class="hljs-class">  <span class="hljs-title">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]</span>)</span>: <span class="hljs-type">Unit</span> = {    println(<span class="hljs-type">MacroTest</span>.macroTest[<span class="hljs-type">A</span>])  }}</code></pre><p>输出结果</p><pre><code class="hljs plain">List(default, default2)</code></pre><h3 id="获取某一类的所有成员"><a href="#获取某一类的所有成员" class="headerlink" title="获取某一类的所有成员"></a>获取某一类的所有成员</h3><p><code>Type.members</code>,如获取<code>t: c.WeakTypeTag[T]</code>中的所有成员:</p><pre><code class="hljs scala">t.tpe.members</code></pre><h3 id="获取方法中参数的默认值"><a href="#获取方法中参数的默认值" class="headerlink" title="获取方法中参数的默认值"></a>获取方法中参数的默认值</h3><p>获取默认参数值的方法命名规则：</p><pre><code class="hljs plain">//类中可以拿到&lt;方法名&gt;$default$&lt;参数下标&gt;</code></pre><p>对于case类中，主构造函数中的默认参数方法命名规则：</p><pre><code class="hljs plain">// 需要在伴生对象中拿到$lessinit$greater$default$&lt;参数下标&gt;</code></pre><h3 id="使用q构造AST时，需要传入参数类型"><a href="#使用q构造AST时，需要传入参数类型" class="headerlink" title="使用q构造AST时，需要传入参数类型"></a>使用<code>q</code>构造AST时，需要传入参数类型</h3><p>可以直接使用<code>t: c.WeakTypeTag[T]</code>:</p><pre><code class="hljs plain">q"def foo[$t]:$t = bar"</code></pre><p>也可以使用<code>Type</code>类型</p><pre><code class="hljs plain">q"def foo[${t.tpe}]: ${t.tpe} = bar"</code></pre><h3 id="构造一个类"><a href="#构造一个类" class="headerlink" title="构造一个类"></a>构造一个类</h3><p>直接使用伴生对象:</p><pre><code class="hljs plain">q"$companion(..$args)"</code></pre><p>或者使用老朋友<code>t: c.WeakTypeTag[T]</code>：</p><pre><code class="hljs plain">q"new $t(..$args)"</code></pre><h3 id="获取前缀c-prefix"><a href="#获取前缀c-prefix" class="headerlink" title="获取前缀c.prefix"></a>获取前缀<code>c.prefix</code></h3><p>比如存在：</p><pre><code class="hljs plain">class Foo[T] {  def bar = macro ???}</code></pre><p>那么：</p><pre><code class="hljs plain">new Foo[String].bar</code></pre><p>的<code>c.prefix.tree</code>就是<code>new Foo[String]</code>,就相当于点的左边。</p><h3 id="定义字符串插值器"><a href="#定义字符串插值器" class="headerlink" title="定义字符串插值器"></a>定义字符串插值器</h3><pre><code class="hljs scala"><span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStringContext</span>(<span class="hljs-params">sc: <span class="hljs-type">StringContext</span></span>) </span>{    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(args: <span class="hljs-type">Any</span>*): <span class="hljs-type">String</span> = ???}</code></pre><p>使用</p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> a = ???<span class="hljs-string">test"hello <span class="hljs-subst">$a</span>"</span><span class="hljs-comment">// 相当与</span><span class="hljs-keyword">val</span> a = ???<span class="hljs-keyword">new</span> <span class="hljs-type">TestStringContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StringContext</span>(<span class="hljs-string">"hello"</span>, <span class="hljs-string">""</span>)).test(a)</code></pre><h3 id="主动提示异常"><a href="#主动提示异常" class="headerlink" title="主动提示异常"></a>主动提示异常</h3><pre><code class="hljs scala">c.error(c.enclosingPosition, <span class="hljs-string">"异常提示"</span>)<span class="hljs-type">EmptyTree</span></code></pre><h3 id="最后一点"><a href="#最后一点" class="headerlink" title="最后一点"></a>最后一点</h3><p>别害怕，print大法好，哪里有疑问print哪里:</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">defaultParamValues</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, _] = macro defaultParamValuesImpl[<span class="hljs-type">T</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">defaultParamValuesImpl</span></span>[<span class="hljs-type">T</span>: c.<span class="hljs-type">WeakTypeTag</span>](c: <span class="hljs-type">Context</span>): c.<span class="hljs-type">Tree</span> = {    <span class="hljs-keyword">import</span> c.universe._    <span class="hljs-keyword">val</span> t = implicitly[c.<span class="hljs-type">WeakTypeTag</span>[<span class="hljs-type">T</span>]]    <span class="hljs-string">q""</span><span class="hljs-string">"</span><span class="hljs-string">    println(${showRaw(t)})</span><span class="hljs-string">    ???</span><span class="hljs-string">    "</span><span class="hljs-string">""</span>  }</code></pre><p><code>showRaw</code>太看不清楚就加个<code>toString</code></p><pre><code class="hljs scala">println(${showRaw(t.toString)})</code></pre><p><code>toString</code>不准确就去掉它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是备忘录，除非你时间很多，否则不建议你阅读。&lt;/p&gt;
&lt;h2 id=&quot;宏代码和测试代码不能在同一个编译环境中&quot;&gt;&lt;a href=&quot;#宏代码</summary>
      
    
    
    
    
    <category term="scala" scheme="http://example.com/tags/scala/"/>
    
    <category term="宏" scheme="http://example.com/tags/%E5%AE%8F/"/>
    
    <category term="编程" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>日常命令手册</title>
    <link href="http://example.com/2021/01/14/%E6%97%A5%E5%B8%B8%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/2021/01/14/%E6%97%A5%E5%B8%B8%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</id>
    <published>2021-01-14T13:24:02.000Z</published>
    <updated>2022-01-26T13:37:52.612Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">ubuntu服务器相关常用命令</a></li><li><a href="#docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">docker 常用命令</a></li><li><a href="#mysql%E6%98%93%E5%BF%98%E5%91%BD%E4%BB%A4">mysql易忘命令</a></li><li><a href="#git%E6%98%93%E5%BF%98%E5%91%BD%E4%BB%A4">git易忘命令</a></li></ul><h2 id="ubuntu服务器相关常用命令"><a href="#ubuntu服务器相关常用命令" class="headerlink" title="ubuntu服务器相关常用命令"></a>ubuntu服务器相关常用命令</h2><p>1、使用ssh登录远程服务器</p><pre><code class="hljs plain">ssh {登陆服务器所用的用户名}@{服务器IP地址}</code></pre><h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><p>1、运行容器</p><pre><code class="hljs plain">sudo docker container start {容器名字}</code></pre><p>2.列出所有容器</p><pre><code class="hljs plain">sudo docker container ls -al</code></pre><p>3.进入正在运行容器的bash界面</p><pre><code class="hljs plain">sudo docker container exec -it {容器名} bash</code></pre><p>4.获取镜像</p><pre><code class="hljs plain">sudo docker pull {镜像名}[:版本号]</code></pre><p>5.运行镜像(运行之后通过镜像生成容器，之后直接运行容器即可)</p><pre><code class="hljs plain">sudo docker run {镜像名}</code></pre><p>6.运行mysql镜像</p><pre><code class="hljs plain">sudo docker run --name {给容器取名} -p {本机端口号}:{docker上的mysql端口号} -e MYSQL_ROOT_PASSWORD={设置mysql登录密码} -d mysql:{TAG}</code></pre><h2 id="mysql易忘命令"><a href="#mysql易忘命令" class="headerlink" title="mysql易忘命令"></a>mysql易忘命令</h2><p>1.进入mysql命令终端</p><pre><code class="hljs plain">mysql -u {用户名} -p</code></pre><h2 id="git易忘命令"><a href="#git易忘命令" class="headerlink" title="git易忘命令"></a>git易忘命令</h2><p>1.创建主仓库</p><pre><code class="hljs plain">git init --bare</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&quot;&gt;ubuntu服务器相关常用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a </summary>
      
    
    
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vue项目配置文档</title>
    <link href="http://example.com/2021/01/14/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/01/14/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</id>
    <published>2021-01-14T13:22:02.000Z</published>
    <updated>2022-01-26T13:37:52.612Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">创建项目</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE">运行项目</a></li><li><a href="#%E5%AE%89%E8%A3%85%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97">安装项目常用模块</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">解决跨域问题</a></li></ul><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><pre><code class="hljs plain">vue create {项目名称}</code></pre><p>选择默认配置</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><pre><code class="hljs plain">npm run serve</code></pre><h2 id="安装项目常用模块"><a href="#安装项目常用模块" class="headerlink" title="安装项目常用模块"></a>安装项目常用模块</h2><p>主要模块</p><pre><code class="hljs plain">npm install axios vue-router vuex node-sass sass-loader vue-axios vue-cookie --save</code></pre><p>可能有用的模块</p><pre><code class="hljs plain">npm install vue-lazyload vue-awesome-swiper --save</code></pre><p>dev安装方式</p><pre><code class="hljs plain">npm install xxx --save-dev</code></pre><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><p>这里使用配置代理服务器的方式来转发请求,首先在项目根目录新建<code>vue.config.js</code>，然后输入如下样例配置:</p><pre><code class="hljs plain">module.exports = {    devServer: {        host: 'localhost',        port: 8080,        proxy: {            '/api': {                target: 'http://localhost:9000',                changeOrigin: true,                pathRewrite: {                    '/api': ''                }            }        }    }}</code></pre><p>以上会将项目中如<code>/api/login</code>的链接转换为<code>http://localhost:9000/login</code>，即<code>/api -&gt; http://localhost:9000/</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE&quot;&gt;创建项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE&quot;&gt;运行项目&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="编程" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="项目配置" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>scala编程之play框架使用</title>
    <link href="http://example.com/2021/01/14/scala%E7%BC%96%E7%A8%8B%E4%B9%8Bplay%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/01/14/scala%E7%BC%96%E7%A8%8B%E4%B9%8Bplay%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-14T13:06:54.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E6%96%B0%E5%BB%BAplay%E9%A1%B9%E7%9B%AE">新建play项目</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE">运行项目</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96">配置依赖</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93mysql">配置数据库(mysql)</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E6%BC%94%E8%BF%9Bevolutions">使用数据库自动演进（evolutions）</a></li><li><a href="#%E4%BD%BF%E7%94%A8slick-codegen%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81">使用<code>slick codegen</code>自动生成数据库操作代码</a></li></ul></li><li><a href="#slick%E4%BD%BF%E7%94%A8">slick使用</a><ul><li><a href="#dao%E7%B1%BB%E6%A8%A1%E6%9D%BF">dao类模板</a></li><li><a href="#%E6%9F%A5">查</a></li><li><a href="#%E5%A2%9E">增</a></li></ul></li><li><a href="#csrf%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE">CSRF过滤器配置</a><ul><li><a href="#%E9%85%8D%E7%BD%AEapplicationconf%E6%96%87%E4%BB%B6">配置<code>application.conf</code>文件</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82">关于前端请求</a></li></ul></li></ul><h2 id="新建play项目"><a href="#新建play项目" class="headerlink" title="新建play项目"></a>新建play项目</h2><pre><code class="hljs plain">sbt new playframework/play-scala-seed.g8</code></pre><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>terminal中运行</p><pre><code class="hljs plain">sbt run</code></pre><p>vscode中运行<br>launch.json文件</p><pre><code class="hljs plain">{    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    "version": "0.2.0",    "configurations": [        {            "type": "scala",            "request": "launch",            "name": "Play main",            "mainClass": "play.core.server.ProdServerStart",            "args": [],            "jvmOptions": []        }    ]}</code></pre><p>application.conf文件添加screatkey</p><pre><code class="hljs plain">play.http.secret.key=${?PLAY_SECREAT_KEY}</code></pre><p><code>~/.bashrc</code>中添加环境变量(如果使用zsh则添加在<code>~/.zshrc</code>中):</p><pre><code class="hljs plain">export PLAY_SECREAT_KEY='QCY?tAnfk?aZ?iwrNwnxIlR6CTf:G3gf:90Latabg@5241AB`R5W:1uDFN];Ik@n'</code></pre><p>刷新.bashrc文件.(关闭所有vscode界面和terminal界面)</p><pre><code class="hljs plain">source .bashrc</code></pre><h2 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h2><p>在build.sbt中添加如下依赖</p><pre><code class="hljs plain">libraryDependencies ++= Seq(  "com.typesafe.play" %% "play-slick" % "5.0.0",  "com.typesafe.play" %% "play-slick-evolutions" % "5.0.0",  "com.typesafe.slick" %% "slick-codegen" % "3.3.3",  "mysql" % "mysql-connector-java" % "5.1.41",  "org.mindrot" % "jbcrypt" % "0.4")</code></pre><h2 id="配置数据库-mysql"><a href="#配置数据库-mysql" class="headerlink" title="配置数据库(mysql)"></a>配置数据库(mysql)</h2><p>在application.conf中添加配置(db.url自行替换):</p><pre><code class="hljs plain"># Default database configurationslick.dbs.default.profile="slick.jdbc.MySQLProfile$"slick.dbs.default.db.driver="com.mysql.jdbc.Driver"slick.dbs.default.db.url="jdbc:mysql://192.168.1.249:3306/seed-store?useSSL=false&amp;characterEncoding=UTF-8"slick.dbs.default.db.user=${?MYSQL_USER}slick.dbs.default.db.password=${?MYSQL_PSD}</code></pre><p>~/.bashrc中添加环境变量:</p><pre><code class="hljs plain">export MYSQL_USER='{用户名}'export MYSQL_PSD='{密码}'</code></pre><p>刷新.bashrc文件.(关闭所有vscode界面和terminal界面)</p><pre><code class="hljs plain">source ~/.bashrc</code></pre><p>配置项目中的logback.xml文件，在<code>&lt;root&gt;</code>节点之前添加以下语句使其能在控制台中显示SQL语句:</p><pre><code class="hljs plain">&lt;logger name="slick.jdbc.JdbcBackend.statement"  level="DEBUG" /&gt;</code></pre><h3 id="使用数据库自动演进（evolutions）"><a href="#使用数据库自动演进（evolutions）" class="headerlink" title="使用数据库自动演进（evolutions）"></a>使用数据库自动演进（evolutions）</h3><p>1.创建如下目录，其中default表示数据库名称（图中为默认数据库）,创建sql文件以1,2,3命名，表示时间先后顺序。</p><!-- ![evolutions](sql_evolutions.png) --><img src="/chuanblog.github.io/2021/01/14/scala%E7%BC%96%E7%A8%8B%E4%B9%8Bplay%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/sql_evolutions.png" class=""><p>2.sql文件样例：</p><p>样例1：</p><pre><code class="hljs plain">-- !UpsDROP TABLE IF EXISTS `user`;CREATE TABLE `user` (    `id` INT AUTO_INCREMENT,    `username` VARCHAR(50) NOT NULL unique,    `password` VARCHAR(50),    `phone_number` VARCHAR(50),    PRIMARY KEY (`id`))ENGINE InnoDB DEFAULT CHARSET=UTF8;-- !DownsDROP TABLE `user`;</code></pre><p>样例2：</p><pre><code class="hljs plain">-- !UpsALTER TABLE `product` ADD CONSTRAINT `prdct_foreign_key_prdct` FOREIGN KEY(`manufacturer_id`)REFERENCES `manufacturer`(`id`);-- !DownsALTER TABLE `product` DROP FOREIGN KEY `prdct_foreign_key_prdct`;</code></pre><p>样例3：</p><pre><code class="hljs plain">-- !UpsCREATE TABLE operator (`id` INT AUTO_INCREMENT,    `username` VARCHAR(50) NOT NULL unique,    `password` VARCHAR(100) NOT NULL,     PRIMARY KEY (`id`))ENGINE InnoDB DEFAULT CHARSET=UTF8;INSERT INTO operator(username, password)VALUES('admin', '$2a$10$D.DPASo7cAvdU9b0URPbY.www8lLK6PkJPQUT/TlWO.S84CYslzZO');-- !DownsDELETE FROM operator where username = 'admin';DROP TABLE operator;</code></pre><p>写好sql之后运行一次项目，然后打开项目网页，会提示运行脚本，运行即可。</p><h3 id="使用slick-codegen自动生成数据库操作代码"><a href="#使用slick-codegen自动生成数据库操作代码" class="headerlink" title="使用slick codegen自动生成数据库操作代码"></a>使用<code>slick codegen</code>自动生成数据库操作代码</h3><p>方法一、在项目中创建一个main方法，每次数据库修改手动运行此main方法：</p><p>在项目源码目录新建scala文件,如下图:</p><!-- ![code_gen](slick_code_gen.png) --><img src="/chuanblog.github.io/2021/01/14/scala%E7%BC%96%E7%A8%8B%E4%B9%8Bplay%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/slick_code_gen.png" class=""><p><code>Codegen.scala</code>文件内容样例如下:</p><pre><code class="hljs plain">import java.io.Fileobject CodeGen extends App {  val dbHost = "localhost:3306"  // val dbHost = "192.168.1.249:3306"  val dbName = "manager-sys-demo"  val dbUserName = System.getenv("MYSQL_USER")  val dbPass = System.getenv("MYSQL_PSD")  val sourceCodeDir = new File("").getAbsolutePath() + File.separator + "app"  slick.codegen.SourceCodeGenerator.main(    Array(      "slick.jdbc.MySQLProfile",      "com.mysql.jdbc.Driver",      s"jdbc:mysql://${dbHost}/${dbName}?useSSL=false&amp;characterEncoding=UTF-8",      sourceCodeDir,      "models",      dbUserName,      dbPass    )  )}</code></pre><p><code>/home/chuanzhangjiang/scala_project/seed-store/app/</code>源码目录,<code>models</code>为源码输出的包，使用里面的<code>Tables</code>对象即可。<br>每次数据库有修改，手动运行<code>Codegen.scala</code>即可。<br>方法二、配置sbt脚本，项目每次编译自动生成<code>Tables</code>对象:<br>修改<code>project</code>目录下的<code>plugins.sbt</code>文件,添加如下内容：</p><pre><code class="hljs plain">addSbtPlugin("com.github.tototoshi" % "sbt-slick-codegen" % "1.4.0")//根据你所使用的数据库而定libraryDependencies += "mysql" % "mysql-connector-java" % "5.1.41"</code></pre><p>修改<code>build.sbt</code>,添加如下内容:</p><pre><code class="hljs plain">import slick.codegen.SourceCodeGeneratorimport slick.{model =&gt; m}val hosetName = "//localhost:3306"val dbName = "manager-sys-demo"// requiredslickCodegenSettings// required// Register codegen hooksourceGenerators in Compile += slickCodegen.taskValue// required 配置数据库urlslickCodegenDatabaseUrl := s"jdbc:mysql:${hosetName}/${dbName}?useSSL=false&amp;characterEncoding=UTF-8"// required 从环境变量中获取登录数据库的用户名slickCodegenDatabaseUser := System.getenv("MYSQL_USER")// required 从环境变量中获取数据库密码slickCodegenDatabasePassword := System.getenv("MYSQL_PSD")// required slickCodegen数据库驱动,非字符串slickCodegenDriver := slick.jdbc.MySQLProfile// required jdbc驱动,字符串slickCodegenJdbcDriver := "com.mysql.jdbc.Driver"// optional but maybe you want `Tables`对象的包名slickCodegenOutputPackage := "models"//optional Tables.scala输出目录// slickCodegenOutputDir := (sourceManaged in Compile).value// optional 忽略指定表// For example, to exclude play evolutions play_evolutions table from the target of codegen. This still applies after slickCodegenIncludedTables.slickCodegenExcludedTables := Seq("play_evolutions")</code></pre><p>完成以上配置，sbt将在你每次编译项目的时候自动生产<code>Tables</code>对象。</p><p>附上<code>slick-codegen</code>sbt插件项目<a href="https://github.com/tototoshi/sbt-slick-codegen">地址</a>。</p><h2 id="slick使用"><a href="#slick使用" class="headerlink" title="slick使用"></a>slick使用</h2><h3 id="dao类模板"><a href="#dao类模板" class="headerlink" title="dao类模板"></a>dao类模板</h3><pre><code class="hljs plain">import play.api.db.slick.DatabaseConfigProviderimport scala.concurrent.ExecutionContextimport com.google.inject.Injectimport play.api.db.slick.HasDatabaseConfigProviderimport slick.jdbc.JdbcProfileimport scala.concurrent.Futureclass SampleDao @Inject() (    protected val dbConfigProvider: DatabaseConfigProvider)(implicit executionContext: ExecutionContext)    extends HasDatabaseConfigProvider[JdbcProfile] {  import profile.api._  // TODO}</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code class="hljs plain">val query = User.filter(_.email === mEmail).resultdb.run(query)</code></pre><p><code>User</code>对象由<code>CodeGen.scala</code>自动生成，参考系列一。</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>情况1:直接新增，返回被修改的行数。</p><pre><code class="hljs plain">def saveUser(newUser: UserRow): Future[Int] = {  val action = User += newUser  db.run(action)}</code></pre><p>情况2:只提供部分列的数据,返回被修改的行数。</p><pre><code class="hljs plain">val action = User.map(user =&gt; (user.username, user.password, user.email)) += (      username,      password,      email    )db.run(action)</code></pre><p>情况3:只提供部分列的数据，返回新增数据的自增id</p><pre><code class="hljs plain">val returnId = User    .map(user =&gt; (user.username, user.password, user.email))    .returning(User.map(_.id))val action = returnId += (    username,    password,    email)</code></pre><p>持续更新中…</p><h2 id="CSRF过滤器配置"><a href="#CSRF过滤器配置" class="headerlink" title="CSRF过滤器配置"></a>CSRF过滤器配置</h2><h3 id="配置application-conf文件"><a href="#配置application-conf文件" class="headerlink" title="配置application.conf文件"></a>配置<code>application.conf</code>文件</h3><p>加入如下行</p><pre><code class="hljs plain">play.filters.csrf.header.bypassHeaders {    X-Requested-With = "*"}</code></pre><h3 id="关于前端请求"><a href="#关于前端请求" class="headerlink" title="关于前端请求"></a>关于前端请求</h3><p>此配置需要在前端请求头中加入<code>X-Requested-With</code>请求头，该请求头的值随意。(有的框架执行ajax请求会自动添加此header，如jquery)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%B0%E5%BB%BAplay%E9%A1%B9%E7%9B%AE&quot;&gt;新建play项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE&quot;&gt;运行项目&lt;/a&gt;&lt;</summary>
      
    
    
    
    
    <category term="scala" scheme="http://example.com/tags/scala/"/>
    
    <category term="编程" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="play framework" scheme="http://example.com/tags/play-framework/"/>
    
  </entry>
  
  <entry>
    <title>openWRT</title>
    <link href="http://example.com/2021/01/14/openWRT/"/>
    <id>http://example.com/2021/01/14/openWRT/</id>
    <published>2021-01-14T13:03:41.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#openwrt%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C">openWRT配置网络</a></li></ul><h2 id="openWRT配置网络"><a href="#openWRT配置网络" class="headerlink" title="openWRT配置网络"></a>openWRT配置网络</h2><p>文件地址:</p><pre><code class="hljs plain">/etc/config/network</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#openwrt%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C&quot;&gt;openWRT配置网络&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;openWRT配置网络&quot;&gt;&lt;a href=&quot;#openWRT配置网络&quot; class</summary>
      
    
    
    
    
    <category term="网络配置" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
    <category term="openWRT" scheme="http://example.com/tags/openWRT/"/>
    
  </entry>
  
  <entry>
    <title>st无法显示emoji问题</title>
    <link href="http://example.com/2021/01/13/st%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAemoji%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/13/st%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAemoji%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-13T14:44:05.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E">问题说明</a></li><li><a href="#%E5%AE%89%E8%A3%85emoji%E6%94%AF%E6%8C%81%E5%AD%97%E4%BD%93">安装emoji支持字体</a></li><li><a href="#%E9%85%8D%E7%BD%AEst">配置st</a></li><li><a href="#%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85">重新编译安装</a></li></ul><h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>问题是由于dwm和st以来的xft出现bug导致的，arch平台可以安装<code>libxft-bgra</code>补丁来修复xft的bug，ubuntu解决此问题不太容易，只能等libxft更新。<br>本文基于ubuntu 20.04,采用迂回战术解决此问题。</p><h2 id="安装emoji支持字体"><a href="#安装emoji支持字体" class="headerlink" title="安装emoji支持字体"></a>安装emoji支持字体</h2><pre><code class="hljs plain">sudo apt install fonts-symbola</code></pre><h2 id="配置st"><a href="#配置st" class="headerlink" title="配置st"></a>配置st</h2><p>安装<a href="https://st.suckless.org/patches/font2/">font2补丁</a>,此处不介绍补丁安装方式。</p><p>修改<code>config.h</code>文件:</p><!-- ![st配置](st-symbola.png) --><img src="/chuanblog.github.io/2021/01/13/st%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAemoji%E9%97%AE%E9%A2%98/st-symbola.png" class=""><h2 id="重新编译安装"><a href="#重新编译安装" class="headerlink" title="重新编译安装"></a>重新编译安装</h2><p>重新编译安装dwm和st即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E&quot;&gt;问题说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85emoji%E6%94%AF%E6%8C%81%E5%AD%97%E4%B</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    <category term="st" scheme="http://example.com/tags/st/"/>
    
  </entry>
  
  <entry>
    <title>zsh安装文档</title>
    <link href="http://example.com/2021/01/13/zsh%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/01/13/zsh%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</id>
    <published>2021-01-13T14:40:26.000Z</published>
    <updated>2022-01-26T13:37:52.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zsh安装"><a href="#zsh安装" class="headerlink" title="zsh安装"></a>zsh安装</h2><pre><code class="hljs plain">sudo apt install zsh</code></pre><h2 id="切换默认shell"><a href="#切换默认shell" class="headerlink" title="切换默认shell"></a>切换默认shell</h2><pre><code class="hljs plain">chsh -s /bin/zsh</code></pre><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h2><pre><code class="hljs plain">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshln -s ~/Desktop/sys-config/.zshrc ~/.zshrc</code></pre><h2 id="安装autojump"><a href="#安装autojump" class="headerlink" title="安装autojump"></a>安装autojump</h2><pre><code class="hljs plain">wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz</code></pre><p>解压，运行其中<code>./install.sh</code></p><p>完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;zsh安装&quot;&gt;&lt;a href=&quot;#zsh安装&quot; class=&quot;headerlink&quot; title=&quot;zsh安装&quot;&gt;&lt;/a&gt;zsh安装&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs plain&quot;&gt;sudo apt install zsh&lt;/code&gt;&lt;/pr</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    <category term="zsh" scheme="http://example.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>ranger预览图片问题</title>
    <link href="http://example.com/2021/01/13/ranger%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/01/13/ranger%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-13T14:38:45.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E9%97%AE%E9%A2%98%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">问题详细描述</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a><ul><li><a href="#ueberzug%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95">ueberzug安装方法</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5">相关链接</a></li></ul><h2 id="问题详细描述"><a href="#问题详细描述" class="headerlink" title="问题详细描述"></a>问题详细描述</h2><p>st使用透明补丁之后，会导致ranger无法使用w3m预览图片。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用<code>ueberzug</code>代替w3m预览图片。</p><h3 id="ueberzug安装方法"><a href="#ueberzug安装方法" class="headerlink" title="ueberzug安装方法"></a>ueberzug安装方法</h3><p>卸载当前<code>ranger</code>：</p><pre><code class="hljs plain">sudo apt remove ranger</code></pre><p>使用pip3安装<code>ranger</code>:</p><pre><code class="hljs plain">pip3 install ranger-fm</code></pre><p>安装<code>ueberzug</code>:</p><pre><code class="hljs plain">pip3 install ueberzug</code></pre><p>修改<code>ranger</code>的rc.conf:</p><pre><code class="hljs plain">set preview_images_method ueberzug</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/seebye/ueberzug">ueberzug</a><br><a href="https://github.com/ranger/ranger">ranger</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0&quot;&gt;问题详细描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%8</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    <category term="ranger" scheme="http://example.com/tags/ranger/"/>
    
    <category term="st" scheme="http://example.com/tags/st/"/>
    
    <category term="图片预览" scheme="http://example.com/tags/%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>nerd字体安装文档</title>
    <link href="http://example.com/2021/01/13/nerd%E5%AD%97%E4%BD%93%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/01/13/nerd%E5%AD%97%E4%BD%93%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</id>
    <published>2021-01-13T14:36:55.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nerd字体全量安装文档"><a href="#Nerd字体全量安装文档" class="headerlink" title="Nerd字体全量安装文档"></a>Nerd字体全量安装文档</h1><h2 id="clone-Nerd仓库"><a href="#clone-Nerd仓库" class="headerlink" title="clone Nerd仓库"></a>clone Nerd仓库</h2><pre><code class="hljs plain">git clone https://github.com/ryanoasis/nerd-fonts.git</code></pre><h2 id="运行-install-sh文件"><a href="#运行-install-sh文件" class="headerlink" title="运行./install.sh文件"></a>运行<code>./install.sh</code>文件</h2><pre><code class="hljs plain">cd nerd-fontssudo chmod u+x install.sh./install.sh</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://github.com/ryanoasis/nerd-fonts">nerd-fonts</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nerd字体全量安装文档&quot;&gt;&lt;a href=&quot;#Nerd字体全量安装文档&quot; class=&quot;headerlink&quot; title=&quot;Nerd字体全量安装文档&quot;&gt;&lt;/a&gt;Nerd字体全量安装文档&lt;/h1&gt;&lt;h2 id=&quot;clone-Nerd仓库&quot;&gt;&lt;a href=&quot;#c</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    <category term="nerd字体" scheme="http://example.com/tags/nerd%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>mutt安装配置文档</title>
    <link href="http://example.com/2021/01/13/mutt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/01/13/mutt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</id>
    <published>2021-01-13T14:33:37.000Z</published>
    <updated>2022-01-26T13:37:52.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">一些准备工作</a></li><li><a href="#%E5%AE%89%E8%A3%85mutt-wizard">安装mutt-wizard</a></li><li><a href="#%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E7%9B%AE%E5%BD%95">需要关注的目录</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E9%82%AE%E7%AE%B1">添加邮箱</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E9%82%AE%E4%BB%B6">同步邮件</a></li><li><a href="#%E6%89%93%E5%BC%80neomutt">打开neomutt</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE">常用操作快捷键</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a><ul><li><a href="#%E5%90%8C%E6%AD%A5%E9%82%AE%E4%BB%B6%E6%97%B6%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8">同步邮件时出现异常</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B9%B1%E7%A0%81">文件夹乱码</a></li><li><a href="#%E4%B8%8D%E8%83%BD%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E9%97%AE%E9%A2%98">不能找到文件夹问题</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>ubuntu 20.04;</p><p>wm: dwm;</p><p>terminal: st;</p><h2 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h2><pre><code class="hljs plain">sudo apt install neomutt //客户端主程序sudo apt install curl sudo apt install isync //拉取邮件工具sudo apt install msmtp //发送邮件工具sudo apt install lynx //简单预览htmlsudo apt install abook //通讯录工具sudo apt install urlview //使用浏览器打开邮件中的链接sudo apt install pass //加密邮箱密码工具</code></pre><h2 id="安装mutt-wizard"><a href="#安装mutt-wizard" class="headerlink" title="安装mutt-wizard"></a>安装mutt-wizard</h2><pre><code class="hljs plain">git clone https://github.com/LukeSmithxyz/mutt-wizardcd mutt-wizardsudo make install</code></pre><p>附上项目github地址：<a href="https://github.com/LukeSmithxyz/mutt-wizard">https://github.com/LukeSmithxyz/mutt-wizard</a></p><h2 id="需要关注的目录"><a href="#需要关注的目录" class="headerlink" title="需要关注的目录"></a>需要关注的目录</h2><pre><code class="hljs plain">~/.mbsyncrc            #isync/mbsync配置文件~/.config/mutt/        #mutt配置文件所在目录~/.local/share/mail/   #isync拉取的邮件保存的目录</code></pre><h2 id="添加邮箱"><a href="#添加邮箱" class="headerlink" title="添加邮箱"></a>添加邮箱</h2><p>首先在系统中生成一对密钥对：</p><pre><code class="hljs plain">gpg full-gen-key</code></pre><p>然后加密存储你的邮箱密码:</p><pre><code class="hljs plain">pass init xxxxx@xx.com</code></pre><p>最后开始添加邮箱账户:</p><pre><code class="hljs plain">mw -a xxxxx@xx.com</code></pre><p>以上操作根据提示输入相关内容即可</p><h2 id="同步邮件"><a href="#同步邮件" class="headerlink" title="同步邮件"></a>同步邮件</h2><p>执行以下命令同步邮件:</p><pre><code class="hljs plain">mbsync xxxxx@xx.com</code></pre><h2 id="打开neomutt"><a href="#打开neomutt" class="headerlink" title="打开neomutt"></a>打开neomutt</h2><p>执行如下命令打开neomutt</p><pre><code class="hljs plain">neomutt</code></pre><h2 id="常用操作快捷键"><a href="#常用操作快捷键" class="headerlink" title="常用操作快捷键"></a>常用操作快捷键</h2><p>打开neomutt之后的常用快捷键</p><pre><code class="hljs plain">m 发送邮件j/k 下/上ctrl-j/k 左边导航栏选择文件夹ctrl-o 打开左边导航栏选中的文件夹l 打开邮件，在按一次，将邮件中的内容和附件列成列表查看h 和l相反r 回复邮件ctrl-b 打开邮件之后将邮件中的url列成列表然后可以用浏览器打开i-[1-9] 进入不同的邮箱帐号a 将选中邮件中的联系人存储到联系人列表中，发件时按tab键选择联系人S 执行操作（如将标记为删除的文件删除）? 帮助（其他快捷键都在这里面）</code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="同步邮件时出现异常"><a href="#同步邮件时出现异常" class="headerlink" title="同步邮件时出现异常"></a>同步邮件时出现异常</h3><pre><code class="hljs plain">C: 0/1  B: 0/0  M: +0/0 *0/0 #0/0  S: +0/0 *0/0 #0/0Error: flattened mailbox name '&amp;UXZO1mWHTvZZOQ-/QQ&amp;kK5O9ouilgU-' contains canonical hierarchy delimiterC: 1/1  B: 0/0  M: +0/0 *0/0 #0/0  S: +0/0 *0/0 #0/0</code></pre><p>打开<code>~/.mbsyncrc</code>,将该邮箱帐号对应频道的的flatten一行注释掉:</p><pre><code class="hljs plain"># flatten .</code></pre><h3 id="文件夹乱码"><a href="#文件夹乱码" class="headerlink" title="文件夹乱码"></a>文件夹乱码</h3><p>将服务端邮箱文件夹改为英文名字（部分邮箱只需要将服务端语言设置为英文即可，部分邮箱不支持修改）。</p><h3 id="不能找到文件夹问题"><a href="#不能找到文件夹问题" class="headerlink" title="不能找到文件夹问题"></a>不能找到文件夹问题</h3><p>问题截图如下:</p><img src="/chuanblog.github.io/2021/01/13/mutt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/cant_found_folder.png" class=""><p>问题原因：文件夹名字中存在空格</p><p>解决方案：转意空格，如下图：</p><img src="/chuanblog.github.io/2021/01/13/mutt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/cant_found_folder2.png" class=""><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可以上这里看看: <a href="https://github.com/LukeSmithxyz/mutt-wizard">https://github.com/LukeSmithxyz/mutt-wizard</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%8E%AF%E5%A2%83&quot;&gt;环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&quot;&gt;一些准备工作&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    <category term="mutt" scheme="http://example.com/tags/mutt/"/>
    
  </entry>
  
  <entry>
    <title>系统安装初始配置文档</title>
    <link href="http://example.com/2021/01/13/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/01/13/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</id>
    <published>2021-01-13T14:25:21.000Z</published>
    <updated>2022-01-26T13:37:52.612Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#deja-dup">deja-dup</a></li><li><a href="#vscode">vscode</a></li><li><a href="#chrome">chrome</a></li><li><a href="#docker">docker</a></li><li><a href="#idea">Idea</a></li><li><a href="#dbeaver">dbeaver</a></li><li><a href="#openjdk11">openJDK11</a></li><li><a href="#sbt">sbt</a></li><li><a href="#u%E7%9B%98%E7%83%A7%E5%BD%95%E5%B7%A5%E5%85%B7">U盘烧录工具</a></li><li><a href="#%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7">截图工具</a></li><li><a href="#vlc%E6%92%AD%E6%94%BE%E5%99%A8">VLC播放器</a></li><li><a href="#node%E7%8E%AF%E5%A2%83">node环境</a></li><li><a href="#node%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%9B%B4%E6%96%B0%E5%91%BD%E4%BB%A4%E5%A6%82vue-cli">node安装的软件包更新命令(如vue-cli)</a></li><li><a href="#%E5%AE%89%E8%A3%85vue-cli">安装vue-cli</a></li><li><a href="#virtualbox">virtualbox</a></li><li><a href="#htop%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8">htop资源管理器</a></li><li><a href="#sensors-cpu%E6%B8%A9%E5%BA%A6%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7">sensors cpu温度监控工具</a></li><li><a href="#emacs">emacs</a></li><li><a href="#%E8%BE%93%E5%85%A5%E6%B3%95">输入法</a></li><li><a href="#atool">atool</a></li><li><a href="#%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98">双系统时间不一致问题</a></li></ul><p>软件安装前首先执行<code>sudo apt update</code>命令。</p><h2 id="deja-dup"><a href="#deja-dup" class="headerlink" title="deja-dup"></a>deja-dup</h2><p>备份工具，用于备份home分区的一些配置文件</p><pre><code class="hljs plain">sudo apt install deja-dup</code></pre><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><p>方法1</p><pre><code class="hljs plain">sudo snap install code --classic</code></pre><p>方法2（推荐）</p><pre><code class="hljs plain">sudo wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - sudo add-apt-repository "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main"sudo apt updatesudo apt install code</code></pre><h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><pre><code class="hljs plain">sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo apt-get updatesudo apt-get install google-chrome-stable</code></pre><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><pre><code class="hljs plain">curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun</code></pre><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><pre><code class="hljs plain">sudo snap install intellij-idea-community --classic</code></pre><h2 id="dbeaver"><a href="#dbeaver" class="headerlink" title="dbeaver"></a>dbeaver</h2><p>数据库管理客户端</p><pre><code class="hljs plain">sudo snap install dbeaver-ce --classic</code></pre><h2 id="openJDK11"><a href="#openJDK11" class="headerlink" title="openJDK11"></a>openJDK11</h2><pre><code class="hljs plain">sudo apt install openjdk-11-jdksudo apt install openjdk-11-source</code></pre><h2 id="sbt"><a href="#sbt" class="headerlink" title="sbt"></a>sbt</h2><pre><code class="hljs plain">echo "deb https://dl.bintray.com/sbt/debian /" | sudo tee -a /etc/apt/sources.list.d/sbt.listcurl -sL "https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823" | sudo apt-key addsudo apt updatesudo apt-get install sbt</code></pre><h2 id="U盘烧录工具"><a href="#U盘烧录工具" class="headerlink" title="U盘烧录工具"></a>U盘烧录工具</h2><pre><code class="hljs plain">sudo apt install usb-creator-gtk</code></pre><h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><pre><code class="hljs plain">sudo apt install flameshot</code></pre><h2 id="VLC播放器"><a href="#VLC播放器" class="headerlink" title="VLC播放器"></a>VLC播放器</h2><pre><code class="hljs plain">sudo snap install vlc</code></pre><h2 id="node环境"><a href="#node环境" class="headerlink" title="node环境"></a>node环境</h2><pre><code class="hljs plain">curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bashsudo apt install -y nodejs</code></pre><h2 id="node安装的软件包更新命令-如vue-cli"><a href="#node安装的软件包更新命令-如vue-cli" class="headerlink" title="node安装的软件包更新命令(如vue-cli)"></a>node安装的软件包更新命令(如vue-cli)</h2><pre><code class="hljs plain">sudo npm update -g [可更上特定包名，不加就更新所有]</code></pre><h2 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h2><pre><code class="hljs plain">sudo npm install -g @vue/cli</code></pre><h2 id="virtualbox"><a href="#virtualbox" class="headerlink" title="virtualbox"></a>virtualbox</h2><pre><code class="hljs plain">wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add - sudo add-apt-repository "deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian $(lsb_release -cs) contrib"sudo apt updatesudo apt instal virtualbox-6.1 #年代久远可以尝试输入virtualbox- 然后tab查看最新版本</code></pre><h2 id="htop资源管理器"><a href="#htop资源管理器" class="headerlink" title="htop资源管理器"></a>htop资源管理器</h2><pre><code class="hljs plain">sudo apt install htop</code></pre><h2 id="sensors-cpu温度监控工具"><a href="#sensors-cpu温度监控工具" class="headerlink" title="sensors cpu温度监控工具"></a>sensors cpu温度监控工具</h2><pre><code class="hljs plain">sudo apt install lm-sensors</code></pre><h2 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h2><pre><code class="hljs plain">sudo apt install emacs</code></pre><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>安装fcitx输入框架</p><pre><code class="hljs plain">sudo apt install fcitx</code></pre><p>将默认输入框架设置为fcitx</p><pre><code class="hljs plain">im-config # 确定 -》选择fcitx</code></pre><p>安装google拼音输入法</p><pre><code class="hljs plain">sudo apt install fcitx-googlepinyin -y</code></pre><p>配置google拼音输入法</p><pre><code class="hljs plain">fcitx-config-gtk3</code></pre><img src="/chuanblog.github.io/2021/01/13/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/fcitx-config01.png" class=""><img src="/chuanblog.github.io/2021/01/13/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/fcitx-config02.png" class=""><h2 id="atool"><a href="#atool" class="headerlink" title="atool"></a>atool</h2><p>ranger文件解压缩支持工具</p><pre><code class="hljs plain">sudo apt install atool</code></pre><h2 id="双系统时间不一致问题"><a href="#双系统时间不一致问题" class="headerlink" title="双系统时间不一致问题"></a>双系统时间不一致问题</h2><pre><code class="hljs plain">sudo hwclock --localtime --systohc</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#deja-dup&quot;&gt;deja-dup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vscode&quot;&gt;vscode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chrome&quot;&gt;chrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#doc</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>dwm安装文档</title>
    <link href="http://example.com/2021/01/13/dwm%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/01/13/dwm%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</id>
    <published>2021-01-13T13:48:37.000Z</published>
    <updated>2022-01-26T13:37:52.606Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#%E5%85%B3%E4%BA%8Edwm">关于DWM</a></li><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E4%BE%9D%E8%B5%96">基础依赖</a></li><li><a href="#%E5%90%8E%E6%9C%9F%E5%8A%9F%E8%83%BD%E6%80%A7%E8%BD%AF%E4%BB%B6">后期功能性软件</a></li></ul></li><li><a href="#dwm%E5%AE%89%E8%A3%85">DWM安装</a></li><li><a href="#%E8%AE%BE%E7%BD%AEdwm%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F">设置DWM启动方式</a><ul><li><a href="#%E4%BD%BF%E7%94%A8display-manager%E5%90%AF%E5%8A%A8">使用display manager启动</a></li><li><a href="#%E4%BD%BF%E7%94%A8startx%E5%91%BD%E4%BB%A4%E4%BB%8E%E6%96%87%E5%AD%97%E7%95%8C%E9%9D%A2%E5%90%AF%E5%8A%A8%E6%8E%A8%E8%8D%90">使用startx命令从文字界面启动(推荐)</a></li></ul></li><li><a href="#%E4%B8%BA%E8%BD%AF%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%89%93%E5%BC%80%E6%A0%87%E7%AD%BE">为软件指定打开标签</a></li><li><a href="#%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">可能遇到的问题</a><ul><li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAemoji">状态栏无法显示emoji</a></li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本教程直接使用本人配置好的DWM，建议新手直接使用我的配置，等上手之后在在行下载官方源码进行编译安装配置。</p><h2 id="关于DWM"><a href="#关于DWM" class="headerlink" title="关于DWM"></a>关于DWM</h2><p>可以看B站CW大佬的<a href="https://www.bilibili.com/video/BV11J411t7RY">视频</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="基础依赖"><a href="#基础依赖" class="headerlink" title="基础依赖"></a>基础依赖</h3><pre><code class="hljs plain">$ sudo apt-get install suckless-tools libx11-dev libxft-dev libxinerama-dev gcc make</code></pre><h3 id="后期功能性软件"><a href="#后期功能性软件" class="headerlink" title="后期功能性软件"></a>后期功能性软件</h3><p>透明配置支持</p><pre><code class="hljs plain">$ sudo apt install compton或者用下面的工具$ sudo apt install xcompmgr</code></pre><p>背景图片设置工具</p><pre><code class="hljs plain">$ sudo apt install feh</code></pre><p>电源监控工具</p><pre><code class="hljs plain">$ sudo apt install acpi acpitool</code></pre><p>背光灯调整工具</p><pre><code class="hljs plain">$ sudo apt install light</code></pre><p>为背光灯调整工具设置sudo免密码</p><pre><code class="hljs plain">$ sudo visudo</code></pre><p>然后在文本最后加入如下代码</p><pre><code class="hljs plain">{登录系统的用户名} ALL=NOPASSWD:/usr/bin/light</code></pre><p>安装截图工具</p><pre><code class="hljs plain">$ sudo apt install flameshot</code></pre><p>安装数字键盘工具</p><pre><code class="hljs plain">$ sudo apt install numlockx</code></pre><p>虚拟机可能需要以下软件</p><p>virtualbox</p><pre><code class="hljs plain">$ sudo apt-get install virtualbox-guest-utils virtualbox-guest-X11</code></pre><p>vmware</p><pre><code class="hljs plain">$ sudo apt-get install open-vm-tools open-vm-desktop</code></pre><h2 id="DWM安装"><a href="#DWM安装" class="headerlink" title="DWM安装"></a>DWM安装</h2><p>获取源码</p><pre><code class="hljs plain">$ git clone https://github.com/chuanzhangjiang/dwm.git</code></pre><p>移动到源码目录修改config.h文件，自行修改下图中用户目录名称</p><img src="/chuanblog.github.io/2021/01/13/dwm%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/config_modify.png" class=""><p>获取dwm自定义脚本</p><pre><code class="hljs plain">$ git clone https://github.com/chuanzhangjiang/dwm-script.git</code></pre><p>将脚本文件软链接到<code>～/.dwm</code>目录</p><pre><code class="hljs plain">$ ln -s  ~/dwm-script的目录 ~/.dwm</code></pre><p>移动到dwm源码目录执行安装命令</p><pre><code class="hljs plain">$ sudo make clean install</code></pre><h2 id="设置DWM启动方式"><a href="#设置DWM启动方式" class="headerlink" title="设置DWM启动方式"></a>设置DWM启动方式</h2><p>有两种启动方式可以选择</p><h3 id="使用display-manager启动"><a href="#使用display-manager启动" class="headerlink" title="使用display manager启动"></a>使用display manager启动</h3><p>以ubuntu 20.04为例,ubuntu 20.04使用gdm3做为display manager，配置完成之后可以在登录界面选择dwm作为桌面启动，如下图：</p><img src="/chuanblog.github.io/2021/01/13/dwm%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/desktop_entry.png" class=""><p>具体配置方式，进入<code>/usr/share/xsessions/</code>目录，新建文件<code>dwm.desktop</code>,输入内容：</p><pre><code class="hljs plain">[Desktop Entry]Encoding=UTF-8Name=DwmComment=Dynamic window managerExec=dwmIcon=dwmType=XSession</code></pre><h3 id="使用startx命令从文字界面启动-推荐"><a href="#使用startx命令从文字界面启动-推荐" class="headerlink" title="使用startx命令从文字界面启动(推荐)"></a>使用startx命令从文字界面启动(推荐)</h3><p>此方式开机更加快速，使用更加灵活，系统资源占用更少。</p><p><strong>首先将系统改为默认进入文字界面</strong></p><p>修改grub配置,打开文件<code>/etc/default/grub</code>,将<code>GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"</code>的改为<code>GRUB_CMDLINE_LINUX_DEFAULT="text"</code>然后执行命令</p><pre><code class="hljs plain">$ sudo update-grub</code></pre><p>将启动等级改为多用户等级，执行如下命令：</p><pre><code class="hljs plain">$ systemctl set-default multi-user.target // 如果想改回启动图形界面执行下面$ systemctl set-default graphical.target</code></pre><p>最后修改<code>~/.xsession</code>文件（如果没有就新建），在最后一行加入</p><pre><code class="hljs plain">exec dwm</code></pre><p>重启电脑，执行startx命令，直接进入dwm，同时也可以执行<code>sudo systemctl start gdm.service</code>命令，打开gdm3的用户登录界面。</p><h2 id="为软件指定打开标签"><a href="#为软件指定打开标签" class="headerlink" title="为软件指定打开标签"></a>为软件指定打开标签</h2><pre><code class="hljs plain">xprop | grep WM_CLASS</code></pre><p>鼠标会变为十字架,用十字架点击想要被指定的软件的打开窗口，terminal就会显示该软件的instance和class:</p><pre><code class="hljs plain">WM_CLASS(STRING) = instance, class</code></pre><p>将信息填入config.h的下列位置:</p><img src="/chuanblog.github.io/2021/01/13/dwm%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/rule.png" class=""><p><code>tags mask</code>用于指定打开的表情序号，一号标签为二进制<code>000000001</code>,二号为<code>000000010</code>,类推。</p><p>重新编译安装即可。<br>完。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="状态栏无法显示emoji"><a href="#状态栏无法显示emoji" class="headerlink" title="状态栏无法显示emoji"></a>状态栏无法显示emoji</h3><p><strong>问题说明</strong><br>问题是由于dwm和st以来的xft出现bug导致的，arch平台可以安装<code>libxft-bgra</code>补丁来修复xft的bug，其他平台解决此问题不太容易，只能等libxft更新。<br>本文基于ubuntu 20.04,采用迂回战术解决此问题。<br><strong>安装emoji支持字体</strong></p><pre><code class="hljs plain">sudo apt install fonts-symbola</code></pre><p><strong>配置dwm</strong><br>修改dwm的<code>config.h</code>文件：</p><img src="/chuanblog.github.io/2021/01/13/dwm%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/dwm-symbola.png" class=""><p><strong>重新编译安装</strong><br>重新编译安装dwm即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E8%A8%80&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E4%BA%8Edwm&quot;&gt;关于DWM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%87%86%E5%A4%87%E5%B</summary>
      
    
    
    
    
    <category term="系统配置" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    <category term="dwm" scheme="http://example.com/tags/dwm/"/>
    
  </entry>
  
</feed>
